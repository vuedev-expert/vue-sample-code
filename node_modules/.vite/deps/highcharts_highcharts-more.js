import {
  __commonJS
} from "./chunk-XHWLKIPX.js";

// node_modules/highcharts/highcharts-more.js
var require_highcharts_more = __commonJS({
  "node_modules/highcharts/highcharts-more.js"(exports, module) {
    (function(d) {
      "object" === typeof module && module.exports ? (d["default"] = d, module.exports = d) : "function" === typeof define && define.amd ? define("highcharts/highcharts-more", ["highcharts"], function(D) {
        d(D);
        d.Highcharts = D;
        return d;
      }) : d("undefined" !== typeof Highcharts ? Highcharts : void 0);
    })(function(d) {
      function D(b, c, h, a) {
        b.hasOwnProperty(c) || (b[c] = a.apply(null, h), "function" === typeof CustomEvent && window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: c, module: b[c] } })));
      }
      d = d ? d._modules : {};
      D(
        d,
        "Extensions/Pane.js",
        [d["Core/Chart/Chart.js"], d["Series/CenteredUtilities.js"], d["Core/Globals.js"], d["Core/Pointer.js"], d["Core/Utilities.js"]],
        function(b, c, h, a, f) {
          function w(g, k, e2, a2, G) {
            var m = true, E = e2[0], v = e2[1], c2 = Math.sqrt(Math.pow(g - E, 2) + Math.pow(k - v, 2));
            q(a2) && q(G) && (g = Math.atan2(r(k - v, 8), r(g - E, 8)), G !== a2 && (m = a2 > G ? g >= a2 && g <= Math.PI || g <= G && g >= -Math.PI : g >= a2 && g <= r(G, 8)));
            return c2 <= Math.ceil(e2[2] / 2) && m;
          }
          var d2 = f.addEvent, r = f.correctFloat, q = f.defined, F = f.extend, p = f.merge, l = f.pick, e = f.splat;
          b.prototype.collectionsWithUpdate.push("pane");
          f = function() {
            function g(k, g2) {
              this.options = this.chart = this.center = this.background = void 0;
              this.coll = "pane";
              this.defaultOptions = { center: ["50%", "50%"], size: "85%", innerSize: "0%", startAngle: 0 };
              this.defaultBackgroundOptions = { shape: "circle", borderWidth: 1, borderColor: "#cccccc", backgroundColor: { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, "#ffffff"], [1, "#e6e6e6"]] }, from: -Number.MAX_VALUE, innerRadius: 0, to: Number.MAX_VALUE, outerRadius: "105%" };
              this.init(k, g2);
            }
            g.prototype.init = function(k, g2) {
              this.chart = g2;
              this.background = [];
              g2.pane.push(this);
              this.setOptions(k);
            };
            g.prototype.setOptions = function(k) {
              this.options = p(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, k);
            };
            g.prototype.render = function() {
              var k = this.options, g2 = this.options.background, a2 = this.chart.renderer;
              this.group || (this.group = a2.g("pane-group").attr({ zIndex: k.zIndex || 0 }).add());
              this.updateCenter();
              if (g2)
                for (g2 = e(g2), k = Math.max(g2.length, this.background.length || 0), a2 = 0; a2 < k; a2++)
                  g2[a2] && this.axis ? this.renderBackground(
                    p(this.defaultBackgroundOptions, g2[a2]),
                    a2
                  ) : this.background[a2] && (this.background[a2] = this.background[a2].destroy(), this.background.splice(a2, 1));
            };
            g.prototype.renderBackground = function(g2, e2) {
              var k = "animate", m = { "class": "highcharts-pane " + (g2.className || "") };
              this.chart.styledMode || F(m, { fill: g2.backgroundColor, stroke: g2.borderColor, "stroke-width": g2.borderWidth });
              this.background[e2] || (this.background[e2] = this.chart.renderer.path().add(this.group), k = "attr");
              this.background[e2][k]({ d: this.axis.getPlotBandPath(g2.from, g2.to, g2) }).attr(m);
            };
            g.prototype.updateCenter = function(g2) {
              this.center = (g2 || this.axis || {}).center = c.getCenter.call(this);
            };
            g.prototype.update = function(g2, e2) {
              p(true, this.options, g2);
              this.setOptions(this.options);
              this.render();
              this.chart.axes.forEach(function(g3) {
                g3.pane === this && (g3.pane = null, g3.update({}, e2));
              }, this);
            };
            return g;
          }();
          b.prototype.getHoverPane = function(g) {
            var e2 = this, m;
            g && e2.pane.forEach(function(k) {
              w(g.chartX - e2.plotLeft, g.chartY - e2.plotTop, k.center) && (m = k);
            });
            return m;
          };
          d2(b, "afterIsInsidePlot", function(g) {
            if (this.polar) {
              if (g.options.inverted) {
                var e2 = [g.y, g.x];
                g.x = e2[0];
                g.y = e2[1];
              }
              g.isInsidePlot = this.pane.some(function(e3) {
                return w(g.x, g.y, e3.center, e3.axis && e3.axis.normalizedStartAngleRad, e3.axis && e3.axis.normalizedEndAngleRad);
              });
            }
          });
          d2(a, "beforeGetHoverData", function(g) {
            var e2 = this.chart;
            e2.polar ? (e2.hoverPane = e2.getHoverPane(g), g.filter = function(k) {
              return k.visible && !(!g.shared && k.directTouch) && l(k.options.enableMouseTracking, true) && (!e2.hoverPane || k.xAxis.pane === e2.hoverPane);
            }) : e2.hoverPane = void 0;
          });
          d2(a, "afterGetHoverData", function(g) {
            var e2 = this.chart;
            g.hoverPoint && g.hoverPoint.plotX && g.hoverPoint.plotY && e2.hoverPane && !w(g.hoverPoint.plotX, g.hoverPoint.plotY, e2.hoverPane.center) && (g.hoverPoint = void 0);
          });
          h.Pane = f;
          return h.Pane;
        }
      );
      D(d, "Series/AreaRange/AreaRangePoint.js", [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(b, c) {
        var h = this && this.__extends || function() {
          var a2 = function(c2, b2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, c3) {
              a3.__proto__ = c3;
            } || function(a3, c3) {
              for (var b3 in c3)
                c3.hasOwnProperty(b3) && (a3[b3] = c3[b3]);
            };
            return a2(c2, b2);
          };
          return function(c2, b2) {
            function f2() {
              this.constructor = c2;
            }
            a2(c2, b2);
            c2.prototype = null === b2 ? Object.create(b2) : (f2.prototype = b2.prototype, new f2());
          };
        }();
        b = b.seriesTypes.area.prototype;
        var a = b.pointClass.prototype, f = c.defined, d2 = c.isNumber;
        return function(c2) {
          function b2() {
            var a2 = null !== c2 && c2.apply(this, arguments) || this;
            a2.high = void 0;
            a2.low = void 0;
            a2.options = void 0;
            a2.plotX = void 0;
            a2.series = void 0;
            return a2;
          }
          h(b2, c2);
          b2.prototype.setState = function() {
            var c3 = this.state, b3 = this.series, h2 = b3.chart.polar;
            f(this.plotHigh) || (this.plotHigh = b3.yAxis.toPixels(
              this.high,
              true
            ));
            f(this.plotLow) || (this.plotLow = this.plotY = b3.yAxis.toPixels(this.low, true));
            b3.stateMarkerGraphic && (b3.lowerStateMarkerGraphic = b3.stateMarkerGraphic, b3.stateMarkerGraphic = b3.upperStateMarkerGraphic);
            this.graphic = this.graphics && this.graphics[1];
            this.plotY = this.plotHigh;
            h2 && d2(this.plotHighX) && (this.plotX = this.plotHighX);
            a.setState.apply(this, arguments);
            this.state = c3;
            this.plotY = this.plotLow;
            this.graphic = this.graphics && this.graphics[0];
            h2 && d2(this.plotLowX) && (this.plotX = this.plotLowX);
            b3.stateMarkerGraphic && (b3.upperStateMarkerGraphic = b3.stateMarkerGraphic, b3.stateMarkerGraphic = b3.lowerStateMarkerGraphic, b3.lowerStateMarkerGraphic = void 0);
            a.setState.apply(this, arguments);
          };
          b2.prototype.haloPath = function() {
            var b3 = this.series.chart.polar, c3 = [];
            this.plotY = this.plotLow;
            b3 && d2(this.plotLowX) && (this.plotX = this.plotLowX);
            this.isInside && (c3 = a.haloPath.apply(this, arguments));
            this.plotY = this.plotHigh;
            b3 && d2(this.plotHighX) && (this.plotX = this.plotHighX);
            this.isTopInside && (c3 = c3.concat(a.haloPath.apply(this, arguments)));
            return c3;
          };
          b2.prototype.isValid = function() {
            return d2(this.low) && d2(this.high);
          };
          return b2;
        }(b.pointClass);
      });
      D(d, "Series/AreaRange/AreaRangeSeries.js", [d["Series/AreaRange/AreaRangePoint.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(b, c, h, a) {
        var f = this && this.__extends || function() {
          var g2 = function(e2, k2) {
            g2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(g3, e3) {
              g3.__proto__ = e3;
            } || function(g3, e3) {
              for (var k3 in e3)
                e3.hasOwnProperty(k3) && (g3[k3] = e3[k3]);
            };
            return g2(e2, k2);
          };
          return function(e2, k2) {
            function m2() {
              this.constructor = e2;
            }
            g2(e2, k2);
            e2.prototype = null === k2 ? Object.create(k2) : (m2.prototype = k2.prototype, new m2());
          };
        }();
        c = c.noop;
        var d2 = h.seriesTypes, n = d2.area, r = d2.area.prototype, q = d2.column.prototype;
        d2 = a.addEvent;
        var F = a.defined, p = a.extend, l = a.isArray, e = a.isNumber, g = a.pick, k = a.merge, m = { lineWidth: 1, threshold: null, tooltip: { pointFormat: '<span style="color:{series.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>' }, trackByArea: true, dataLabels: {
          align: void 0,
          verticalAlign: void 0,
          xLow: 0,
          xHigh: 0,
          yLow: 0,
          yHigh: 0
        } };
        a = function(e2) {
          function a2() {
            var g2 = null !== e2 && e2.apply(this, arguments) || this;
            g2.data = void 0;
            g2.options = void 0;
            g2.points = void 0;
            g2.lowerStateMarkerGraphic = void 0;
            g2.xAxis = void 0;
            return g2;
          }
          f(a2, e2);
          a2.prototype.toYData = function(g2) {
            return [g2.low, g2.high];
          };
          a2.prototype.highToXY = function(g2) {
            var e3 = this.chart, k2 = this.xAxis.postTranslate(g2.rectPlotX || 0, this.yAxis.len - (g2.plotHigh || 0));
            g2.plotHighX = k2.x - e3.plotLeft;
            g2.plotHigh = k2.y - e3.plotTop;
            g2.plotLowX = g2.plotX;
          };
          a2.prototype.getGraphPath = function(e3) {
            var k2 = [], a3 = [], m2 = r.getGraphPath, b2 = this.options, c2 = this.chart.polar, x = c2 && false !== b2.connectEnds, B = b2.connectNulls, y, f2 = b2.step;
            e3 = e3 || this.points;
            for (y = e3.length; y--; ) {
              var t = e3[y];
              var G = c2 ? { plotX: t.rectPlotX, plotY: t.yBottom, doCurve: false } : { plotX: t.plotX, plotY: t.plotY, doCurve: false };
              t.isNull || x || B || e3[y + 1] && !e3[y + 1].isNull || a3.push(G);
              var l2 = { polarPlotY: t.polarPlotY, rectPlotX: t.rectPlotX, yBottom: t.yBottom, plotX: g(t.plotHighX, t.plotX), plotY: t.plotHigh, isNull: t.isNull };
              a3.push(l2);
              k2.push(l2);
              t.isNull || x || B || e3[y - 1] && !e3[y - 1].isNull || a3.push(G);
            }
            e3 = m2.call(this, e3);
            f2 && (true === f2 && (f2 = "left"), b2.step = { left: "right", center: "center", right: "left" }[f2]);
            k2 = m2.call(this, k2);
            a3 = m2.call(this, a3);
            b2.step = f2;
            b2 = [].concat(e3, k2);
            !this.chart.polar && a3[0] && "M" === a3[0][0] && (a3[0] = ["L", a3[0][1], a3[0][2]]);
            this.graphPath = b2;
            this.areaPath = e3.concat(a3);
            b2.isArea = true;
            b2.xMap = e3.xMap;
            this.areaPath.xMap = e3.xMap;
            return b2;
          };
          a2.prototype.drawDataLabels = function() {
            var e3 = this.points, g2 = e3.length, k2 = [], a3 = this.options.dataLabels, m2 = this.chart.inverted, b2, x;
            if (a3) {
              if (l(a3)) {
                var c2 = a3[0] || { enabled: false };
                var y = a3[1] || { enabled: false };
              } else
                c2 = p({}, a3), c2.x = a3.xHigh, c2.y = a3.yHigh, y = p({}, a3), y.x = a3.xLow, y.y = a3.yLow;
              if (c2.enabled || this._hasPointLabels) {
                for (b2 = g2; b2--; )
                  if (x = e3[b2]) {
                    var f2 = x.plotHigh;
                    f2 = void 0 === f2 ? 0 : f2;
                    var t = x.plotLow;
                    t = void 0 === t ? 0 : t;
                    t = c2.inside ? f2 < t : f2 > t;
                    x.y = x.high;
                    x._plotY = x.plotY;
                    x.plotY = f2;
                    k2[b2] = x.dataLabel;
                    x.dataLabel = x.dataLabelUpper;
                    x.below = t;
                    m2 ? c2.align || (c2.align = t ? "right" : "left") : c2.verticalAlign || (c2.verticalAlign = t ? "top" : "bottom");
                  }
                this.options.dataLabels = c2;
                r.drawDataLabels && r.drawDataLabels.apply(this, arguments);
                for (b2 = g2; b2--; )
                  if (x = e3[b2])
                    x.dataLabelUpper = x.dataLabel, x.dataLabel = k2[b2], delete x.dataLabels, x.y = x.low, x.plotY = x._plotY;
              }
              if (y.enabled || this._hasPointLabels) {
                for (b2 = g2; b2--; )
                  if (x = e3[b2])
                    k2 = x.plotHigh, f2 = void 0 === k2 ? 0 : k2, k2 = x.plotLow, t = void 0 === k2 ? 0 : k2, t = y.inside ? f2 < t : f2 > t, x.below = !t, m2 ? y.align || (y.align = t ? "left" : "right") : y.verticalAlign || (y.verticalAlign = t ? "bottom" : "top");
                this.options.dataLabels = y;
                r.drawDataLabels && r.drawDataLabels.apply(this, arguments);
              }
              if (c2.enabled) {
                for (b2 = g2; b2--; )
                  if (x = e3[b2])
                    x.dataLabels = [x.dataLabelUpper, x.dataLabel].filter(function(e4) {
                      return !!e4;
                    });
              }
              this.options.dataLabels = a3;
            }
          };
          a2.prototype.alignDataLabel = function() {
            q.alignDataLabel.apply(this, arguments);
          };
          a2.prototype.drawPoints = function() {
            var e3 = this.points.length, k2;
            r.drawPoints.apply(this, arguments);
            for (k2 = 0; k2 < e3; ) {
              var a3 = this.points[k2];
              a3.graphics = a3.graphics || [];
              a3.origProps = { plotY: a3.plotY, plotX: a3.plotX, isInside: a3.isInside, negative: a3.negative, zone: a3.zone, y: a3.y };
              if (a3.graphic || a3.graphics[0])
                a3.graphics[0] = a3.graphic;
              a3.graphic = a3.graphics[1];
              a3.plotY = a3.plotHigh;
              F(a3.plotHighX) && (a3.plotX = a3.plotHighX);
              a3.y = g(
                a3.high,
                a3.origProps.y
              );
              a3.negative = a3.y < (this.options.threshold || 0);
              this.zones.length && (a3.zone = a3.getZone());
              this.chart.polar || (a3.isInside = a3.isTopInside = "undefined" !== typeof a3.plotY && 0 <= a3.plotY && a3.plotY <= this.yAxis.len && 0 <= a3.plotX && a3.plotX <= this.xAxis.len);
              k2++;
            }
            r.drawPoints.apply(this, arguments);
            for (k2 = 0; k2 < e3; ) {
              a3 = this.points[k2];
              a3.graphics = a3.graphics || [];
              if (a3.graphic || a3.graphics[1])
                a3.graphics[1] = a3.graphic;
              a3.graphic = a3.graphics[0];
              a3.origProps && (p(a3, a3.origProps), delete a3.origProps);
              k2++;
            }
          };
          a2.defaultOptions = k(
            n.defaultOptions,
            m
          );
          return a2;
        }(n);
        d2(a, "afterTranslate", function() {
          var g2 = this;
          "low,high" === this.pointArrayMap.join(",") && this.points.forEach(function(a2) {
            var k2 = a2.high, m2 = a2.plotY;
            a2.isNull ? a2.plotY = void 0 : (a2.plotLow = m2, a2.plotHigh = e(k2) ? g2.yAxis.translate(g2.dataModify ? g2.dataModify.modifyValue(k2) : k2, false, true, void 0, true) : void 0, g2.dataModify && (a2.yBottom = a2.plotHigh));
          });
        }, { order: 0 });
        d2(a, "afterTranslate", function() {
          var e2 = this;
          this.points.forEach(function(g2) {
            if (e2.chart.polar)
              e2.highToXY(g2), g2.plotLow = g2.plotY, g2.tooltipPos = [((g2.plotHighX || 0) + (g2.plotLowX || 0)) / 2, ((g2.plotHigh || 0) + (g2.plotLow || 0)) / 2];
            else {
              var a2 = g2.pos(false, g2.plotLow), k2 = g2.pos(false, g2.plotHigh);
              a2 && k2 && (a2[0] = (a2[0] + k2[0]) / 2, a2[1] = (a2[1] + k2[1]) / 2);
              g2.tooltipPos = a2;
            }
          });
        }, { order: 3 });
        p(a.prototype, { deferTranslatePolar: true, pointArrayMap: ["low", "high"], pointClass: b, pointValKey: "low", setStackedPoints: c });
        h.registerSeriesType("arearange", a);
        "";
        return a;
      });
      D(
        d,
        "Series/AreaSplineRange/AreaSplineRangeSeries.js",
        [d["Series/AreaRange/AreaRangeSeries.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]],
        function(b, c, h) {
          var a = this && this.__extends || function() {
            var a2 = function(b2, c2) {
              a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
                a3.__proto__ = b3;
              } || function(a3, b3) {
                for (var e in b3)
                  b3.hasOwnProperty(e) && (a3[e] = b3[e]);
              };
              return a2(b2, c2);
            };
            return function(b2, c2) {
              function f2() {
                this.constructor = b2;
              }
              a2(b2, c2);
              b2.prototype = null === c2 ? Object.create(c2) : (f2.prototype = c2.prototype, new f2());
            };
          }(), f = c.seriesTypes.spline.prototype, d2 = h.merge;
          h = h.extend;
          var n = function(c2) {
            function f2() {
              var a2 = null !== c2 && c2.apply(this, arguments) || this;
              a2.options = void 0;
              a2.data = void 0;
              a2.points = void 0;
              return a2;
            }
            a(f2, c2);
            f2.defaultOptions = d2(b.defaultOptions);
            return f2;
          }(b);
          h(n.prototype, { getPointSpline: f.getPointSpline });
          c.registerSeriesType("areasplinerange", n);
          "";
          return n;
        }
      );
      D(d, "Series/BoxPlot/BoxPlotSeries.js", [d["Series/Column/ColumnSeries.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(b, c, h, a) {
        var f = this && this.__extends || function() {
          var a2 = function(b2, c2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, e) {
              a3.__proto__ = e;
            } || function(a3, e) {
              for (var g in e)
                e.hasOwnProperty(g) && (a3[g] = e[g]);
            };
            return a2(b2, c2);
          };
          return function(b2, c2) {
            function f2() {
              this.constructor = b2;
            }
            a2(b2, c2);
            b2.prototype = null === c2 ? Object.create(c2) : (f2.prototype = c2.prototype, new f2());
          };
        }();
        c = c.noop;
        var d2 = a.extend, n = a.merge, r = a.pick;
        a = function(a2) {
          function c2() {
            var b2 = null !== a2 && a2.apply(this, arguments) || this;
            b2.data = void 0;
            b2.options = void 0;
            b2.points = void 0;
            return b2;
          }
          f(c2, a2);
          c2.prototype.pointAttribs = function() {
            return {};
          };
          c2.prototype.translate = function() {
            var b2 = this.yAxis, c3 = this.pointArrayMap;
            a2.prototype.translate.apply(this);
            this.points.forEach(function(a3) {
              c3.forEach(function(g) {
                null !== a3[g] && (a3[g + "Plot"] = b2.translate(a3[g], 0, 1, 0, 1));
              });
              a3.plotHigh = a3.highPlot;
            });
          };
          c2.prototype.drawPoints = function() {
            var a3 = this, b2 = a3.options, e = a3.chart, g = e.renderer, k, c3, f2, h2, d3, E, v = 0, n2, I, K, x, B = false !== a3.doQuartiles, y, H = a3.options.whiskerLength;
            a3.points.forEach(function(m) {
              var t = m.graphic, G = t ? "animate" : "attr", N = m.shapeArgs, L = {}, l = {}, w = {}, u = {}, C = m.color || a3.color;
              "undefined" !== typeof m.plotY && (n2 = Math.round(N.width), I = Math.floor(N.x), K = I + n2, x = Math.round(n2 / 2), k = Math.floor(B ? m.q1Plot : m.lowPlot), c3 = Math.floor(B ? m.q3Plot : m.lowPlot), f2 = Math.floor(m.highPlot), h2 = Math.floor(m.lowPlot), t || (m.graphic = t = g.g("point").add(a3.group), m.stem = g.path().addClass("highcharts-boxplot-stem").add(t), H && (m.whiskers = g.path().addClass("highcharts-boxplot-whisker").add(t)), B && (m.box = g.path(void 0).addClass("highcharts-boxplot-box").add(t)), m.medianShape = g.path(void 0).addClass("highcharts-boxplot-median").add(t)), e.styledMode || (l.stroke = m.stemColor || b2.stemColor || C, l["stroke-width"] = r(m.stemWidth, b2.stemWidth, b2.lineWidth), l.dashstyle = m.stemDashStyle || b2.stemDashStyle || b2.dashStyle, m.stem.attr(l), H && (w.stroke = m.whiskerColor || b2.whiskerColor || C, w["stroke-width"] = r(m.whiskerWidth, b2.whiskerWidth, b2.lineWidth), w.dashstyle = m.whiskerDashStyle || b2.whiskerDashStyle || b2.dashStyle, m.whiskers.attr(w)), B && (L.fill = m.fillColor || b2.fillColor || C, L.stroke = b2.lineColor || C, L["stroke-width"] = b2.lineWidth || 0, L.dashstyle = m.boxDashStyle || b2.boxDashStyle || b2.dashStyle, m.box.attr(L)), u.stroke = m.medianColor || b2.medianColor || C, u["stroke-width"] = r(m.medianWidth, b2.medianWidth, b2.lineWidth), u.dashstyle = m.medianDashStyle || b2.medianDashStyle || b2.dashStyle, m.medianShape.attr(u)), E = m.stem.strokeWidth() % 2 / 2, v = I + x + E, t = [["M", v, c3], ["L", v, f2], ["M", v, k], ["L", v, h2]], m.stem[G]({ d: t }), B && (E = m.box.strokeWidth() % 2 / 2, k = Math.floor(k) + E, c3 = Math.floor(c3) + E, I += E, K += E, t = [["M", I, c3], ["L", I, k], ["L", K, k], ["L", K, c3], ["L", I, c3], ["Z"]], m.box[G]({ d: t })), H && (E = m.whiskers.strokeWidth() % 2 / 2, f2 += E, h2 += E, y = /%$/.test(H) ? x * parseFloat(H) / 100 : H / 2, t = [["M", v - y, f2], ["L", v + y, f2], ["M", v - y, h2], ["L", v + y, h2]], m.whiskers[G]({ d: t })), d3 = Math.round(m.medianPlot), E = m.medianShape.strokeWidth() % 2 / 2, d3 += E, t = [["M", I, d3], ["L", K, d3]], m.medianShape[G]({ d: t }));
            });
          };
          c2.prototype.toYData = function(a3) {
            return [a3.low, a3.q1, a3.median, a3.q3, a3.high];
          };
          c2.defaultOptions = n(b.defaultOptions, {
            threshold: null,
            tooltip: { pointFormat: '<span style="color:{point.color}">\u25CF</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>' },
            whiskerLength: "50%",
            fillColor: "#ffffff",
            lineWidth: 1,
            medianWidth: 2,
            whiskerWidth: 2
          });
          return c2;
        }(b);
        d2(a.prototype, { pointArrayMap: ["low", "q1", "median", "q3", "high"], pointValKey: "high", drawDataLabels: c, setStackedPoints: c });
        h.registerSeriesType("boxplot", a);
        "";
        return a;
      });
      D(d, "Series/Bubble/BubbleLegendDefaults.js", [], function() {
        return { borderColor: void 0, borderWidth: 2, className: void 0, color: void 0, connectorClassName: void 0, connectorColor: void 0, connectorDistance: 60, connectorWidth: 1, enabled: false, labels: {
          className: void 0,
          allowOverlap: false,
          format: "",
          formatter: void 0,
          align: "right",
          style: { fontSize: "10px", color: "#000000" },
          x: 0,
          y: 0
        }, maxSize: 60, minSize: 10, legendIndex: 0, ranges: { value: void 0, borderColor: void 0, color: void 0, connectorColor: void 0 }, sizeBy: "area", sizeByAbsoluteValue: false, zIndex: 1, zThreshold: 0 };
      });
      D(d, "Series/Bubble/BubbleLegendItem.js", [d["Core/Color/Color.js"], d["Core/FormatUtilities.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function(b, c, h, a) {
        var f = b.parse, d2 = h.noop, n = a.arrayMax, r = a.arrayMin, q = a.isNumber, F = a.merge, p = a.pick, l = a.stableSort;
        b = function() {
          function a2(a3, e) {
            this.options = this.symbols = this.visible = this.selected = this.ranges = this.movementX = this.maxLabel = this.legend = this.fontMetrics = this.chart = void 0;
            this.setState = d2;
            this.init(a3, e);
          }
          a2.prototype.init = function(a3, e) {
            this.options = a3;
            this.visible = true;
            this.chart = e.chart;
            this.legend = e;
          };
          a2.prototype.addToLegend = function(a3) {
            a3.splice(this.options.legendIndex, 0, this);
          };
          a2.prototype.drawLegendSymbol = function(a3) {
            var g = this.chart, e = p(a3.options.itemDistance, 20), b2 = this.legendItem || {}, c2 = this.options, f2 = c2.ranges, h2 = c2.connectorDistance;
            this.fontMetrics = g.renderer.fontMetrics(c2.labels.style.fontSize);
            f2 && f2.length && q(f2[0].value) ? (l(f2, function(a4, g2) {
              return g2.value - a4.value;
            }), this.ranges = f2, this.setOptions(), this.render(), a3 = this.getMaxLabelSize(), f2 = this.ranges[0].radius, g = 2 * f2, h2 = h2 - f2 + a3.width, h2 = 0 < h2 ? h2 : 0, this.maxLabel = a3, this.movementX = "left" === c2.labels.align ? h2 : 0, b2.labelWidth = g + h2 + e, b2.labelHeight = g + this.fontMetrics.h / 2) : a3.options.bubbleLegend.autoRanges = true;
          };
          a2.prototype.setOptions = function() {
            var a3 = this.ranges, e = this.options, b2 = this.chart.series[e.seriesIndex], c2 = this.legend.baseline, h2 = { zIndex: e.zIndex, "stroke-width": e.borderWidth }, d3 = { zIndex: e.zIndex, "stroke-width": e.connectorWidth }, E = { align: this.legend.options.rtl || "left" === e.labels.align ? "right" : "left", zIndex: e.zIndex }, v = b2.options.marker.fillOpacity, l2 = this.chart.styledMode;
            a3.forEach(function(g, k) {
              l2 || (h2.stroke = p(g.borderColor, e.borderColor, b2.color), h2.fill = p(g.color, e.color, 1 !== v ? f(b2.color).setOpacity(v).get("rgba") : b2.color), d3.stroke = p(
                g.connectorColor,
                e.connectorColor,
                b2.color
              ));
              a3[k].radius = this.getRangeRadius(g.value);
              a3[k] = F(a3[k], { center: a3[0].radius - a3[k].radius + c2 });
              l2 || F(true, a3[k], { bubbleAttribs: F(h2), connectorAttribs: F(d3), labelAttribs: E });
            }, this);
          };
          a2.prototype.getRangeRadius = function(a3) {
            var e = this.options;
            return this.chart.series[this.options.seriesIndex].getRadius.call(this, e.ranges[e.ranges.length - 1].value, e.ranges[0].value, e.minSize, e.maxSize, a3);
          };
          a2.prototype.render = function() {
            var a3 = this.legendItem || {}, e = this.chart.renderer, b2 = this.options.zThreshold;
            this.symbols || (this.symbols = { connectors: [], bubbleItems: [], labels: [] });
            a3.symbol = e.g("bubble-legend");
            a3.label = e.g("bubble-legend-item");
            a3.symbol.translateX = 0;
            e = a3.symbol.translateY = 0;
            for (var c2 = this.ranges; e < c2.length; e++) {
              var f2 = c2[e];
              f2.value >= b2 && this.renderRange(f2);
            }
            a3.symbol.add(a3.label);
            a3.label.add(a3.group);
            this.hideOverlappingLabels();
          };
          a2.prototype.renderRange = function(a3) {
            var e = this.options, g = e.labels, b2 = this.chart, c2 = b2.series[e.seriesIndex], f2 = b2.renderer, h2 = this.symbols;
            b2 = h2.labels;
            var d3 = a3.center, l2 = Math.abs(a3.radius), I = e.connectorDistance || 0, K = g.align, x = e.connectorWidth, B = this.ranges[0].radius || 0, y = d3 - l2 - e.borderWidth / 2 + x / 2, H = this.fontMetrics;
            H = H.f / 2 - (H.h - H.f) / 2;
            var t = f2.styledMode;
            I = this.legend.options.rtl || "left" === K ? -I : I;
            "center" === K && (I = 0, e.connectorDistance = 0, a3.labelAttribs.align = "center");
            K = y + e.labels.y;
            var n2 = B + I + e.labels.x;
            h2.bubbleItems.push(f2.circle(B, d3 + ((y % 1 ? 1 : 0.5) - (x % 2 ? 0 : 0.5)), l2).attr(t ? {} : a3.bubbleAttribs).addClass((t ? "highcharts-color-" + c2.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (e.className || "")).add(this.legendItem.symbol));
            h2.connectors.push(f2.path(f2.crispLine([["M", B, y], ["L", B + I, y]], e.connectorWidth)).attr(t ? {} : a3.connectorAttribs).addClass((t ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (e.connectorClassName || "")).add(this.legendItem.symbol));
            a3 = f2.text(this.formatLabel(a3), n2, K + H).attr(t ? {} : a3.labelAttribs).css(t ? {} : g.style).addClass("highcharts-bubble-legend-labels " + (e.labels.className || "")).add(this.legendItem.symbol);
            b2.push(a3);
            a3.placed = true;
            a3.alignAttr = { x: n2, y: K + H };
          };
          a2.prototype.getMaxLabelSize = function() {
            var a3, e;
            this.symbols.labels.forEach(function(g) {
              e = g.getBBox(true);
              a3 = a3 ? e.width > a3.width ? e : a3 : e;
            });
            return a3 || {};
          };
          a2.prototype.formatLabel = function(a3) {
            var e = this.options, g = e.labels.formatter;
            e = e.labels.format;
            var b2 = this.chart.numberFormatter;
            return e ? c.format(e, a3) : g ? g.call(a3) : b2(a3.value, 1);
          };
          a2.prototype.hideOverlappingLabels = function() {
            var a3 = this.chart, e = this.symbols;
            !this.options.labels.allowOverlap && e && (a3.hideOverlappingLabels(e.labels), e.labels.forEach(function(a4, g) {
              a4.newOpacity ? a4.newOpacity !== a4.oldOpacity && e.connectors[g].show() : e.connectors[g].hide();
            }));
          };
          a2.prototype.getRanges = function() {
            var a3 = this.legend.bubbleLegend, e = a3.options.ranges, b2, c2 = Number.MAX_VALUE, f2 = -Number.MAX_VALUE;
            a3.chart.series.forEach(function(a4) {
              a4.isBubble && !a4.ignoreSeries && (b2 = a4.zData.filter(q), b2.length && (c2 = p(a4.options.zMin, Math.min(c2, Math.max(r(b2), false === a4.options.displayNegative ? a4.options.zThreshold : -Number.MAX_VALUE))), f2 = p(a4.options.zMax, Math.max(f2, n(b2)))));
            });
            var h2 = c2 === f2 ? [{ value: f2 }] : [
              { value: c2 },
              { value: (c2 + f2) / 2 },
              { value: f2, autoRanges: true }
            ];
            e.length && e[0].radius && h2.reverse();
            h2.forEach(function(a4, g) {
              e && e[g] && (h2[g] = F(e[g], a4));
            });
            return h2;
          };
          a2.prototype.predictBubbleSizes = function() {
            var a3 = this.chart, e = this.fontMetrics, b2 = a3.legend.options, c2 = b2.floating, f2 = (b2 = "horizontal" === b2.layout) ? a3.legend.lastLineHeight : 0, h2 = a3.plotSizeX, d3 = a3.plotSizeY, v = a3.series[this.options.seriesIndex], l2 = v.getPxExtremes();
            a3 = Math.ceil(l2.minPxSize);
            l2 = Math.ceil(l2.maxPxSize);
            var I = Math.min(d3, h2);
            v = v.options.maxSize;
            if (c2 || !/%$/.test(v))
              e = l2;
            else if (v = parseFloat(v), e = (I + f2 - e.h / 2) * v / 100 / (v / 100 + 1), b2 && d3 - e >= h2 || !b2 && h2 - e >= d3)
              e = l2;
            return [a3, Math.ceil(e)];
          };
          a2.prototype.updateRanges = function(a3, e) {
            var b2 = this.legend.options.bubbleLegend;
            b2.minSize = a3;
            b2.maxSize = e;
            b2.ranges = this.getRanges();
          };
          a2.prototype.correctSizes = function() {
            var a3 = this.legend, e = this.chart.series[this.options.seriesIndex].getPxExtremes();
            1 < Math.abs(Math.ceil(e.maxPxSize) - this.options.maxSize) && (this.updateRanges(this.options.minSize, e.maxPxSize), a3.render());
          };
          return a2;
        }();
        "";
        return b;
      });
      D(
        d,
        "Series/Bubble/BubbleLegendComposition.js",
        [d["Series/Bubble/BubbleLegendDefaults.js"], d["Series/Bubble/BubbleLegendItem.js"], d["Core/Defaults.js"], d["Core/Utilities.js"]],
        function(b, c, h, a) {
          function f(a2, b2, g2) {
            var c2 = this.legend, m = 0 <= d2(this), f2;
            if (c2 && c2.options.enabled && c2.bubbleLegend && c2.options.bubbleLegend.autoRanges && m) {
              var k2 = c2.bubbleLegend.options;
              m = c2.bubbleLegend.predictBubbleSizes();
              c2.bubbleLegend.updateRanges(m[0], m[1]);
              k2.placed || (c2.group.placed = false, c2.allItems.forEach(function(a3) {
                f2 = a3.legendItem || {};
                f2.group && (f2.group.translateY = null);
              }));
              c2.render();
              this.getMargins();
              this.axes.forEach(function(a3) {
                a3.visible && a3.render();
                k2.placed || (a3.setScale(), a3.updateNames(), e(a3.ticks, function(a4) {
                  a4.isNew = true;
                  a4.isNewLabel = true;
                }));
              });
              k2.placed = true;
              this.getMargins();
              a2.call(this, b2, g2);
              c2.bubbleLegend.correctSizes();
              F(c2, n(c2));
            } else
              a2.call(this, b2, g2), c2 && c2.options.enabled && c2.bubbleLegend && (c2.render(), F(c2, n(c2)));
          }
          function d2(a2) {
            a2 = a2.series;
            for (var e2 = 0; e2 < a2.length; ) {
              if (a2[e2] && a2[e2].isBubble && a2[e2].visible && a2[e2].zData.length)
                return e2;
              e2++;
            }
            return -1;
          }
          function n(a2) {
            a2 = a2.allItems;
            var e2 = [], b2 = a2.length, g2, c2 = 0;
            for (g2 = 0; g2 < b2; g2++) {
              var f2 = a2[g2].legendItem || {};
              var k2 = (a2[g2 + 1] || {}).legendItem || {};
              f2.labelHeight && (a2[g2].itemHeight = f2.labelHeight);
              if (a2[g2] === a2[b2 - 1] || f2.y !== k2.y) {
                e2.push({ height: 0 });
                f2 = e2[e2.length - 1];
                for (c2; c2 <= g2; c2++)
                  a2[c2].itemHeight > f2.height && (f2.height = a2[c2].itemHeight);
                f2.step = g2;
              }
            }
            return e2;
          }
          function r(a2) {
            var e2 = this.bubbleLegend, b2 = this.options, g2 = b2.bubbleLegend, f2 = d2(this.chart);
            e2 && e2.ranges && e2.ranges.length && (g2.ranges.length && (g2.autoRanges = !!g2.ranges[0].autoRanges), this.destroyItem(e2));
            0 <= f2 && b2.enabled && g2.enabled && (g2.seriesIndex = f2, this.bubbleLegend = new c(g2, this), this.bubbleLegend.addToLegend(a2.allItems));
          }
          function q() {
            var a2 = this.chart, e2 = this.visible, b2 = this.chart.legend;
            b2 && b2.bubbleLegend && (this.visible = !e2, this.ignoreSeries = e2, a2 = 0 <= d2(a2), b2.bubbleLegend.visible !== a2 && (b2.update({ bubbleLegend: { enabled: a2 } }), b2.bubbleLegend.visible = a2), this.visible = e2);
          }
          function F(a2, e2) {
            var b2 = a2.options.rtl, g2, c2, f2, k2, m = 0;
            a2.allItems.forEach(function(a3, x) {
              k2 = a3.legendItem || {};
              if (k2.group) {
                g2 = k2.group.translateX || 0;
                c2 = k2.y || 0;
                if ((f2 = a3.movementX) || b2 && a3.ranges)
                  f2 = b2 ? g2 - a3.options.maxSize / 2 : g2 + f2, k2.group.attr({ translateX: f2 });
                x > e2[m].step && m++;
                k2.group.attr({ translateY: Math.round(c2 + e2[m].height / 2) });
                k2.y = c2 + e2[m].height / 2;
              }
            });
          }
          var p = h.setOptions, l = a.addEvent, e = a.objectEach, g = a.wrap, k = [];
          return { compose: function(a2, e2, c2) {
            -1 === k.indexOf(a2) && (k.push(a2), p({ legend: { bubbleLegend: b } }), g(a2.prototype, "drawChartBox", f));
            -1 === k.indexOf(e2) && (k.push(e2), l(e2, "afterGetAllItems", r));
            -1 === k.indexOf(c2) && (k.push(c2), l(c2, "legendItemClick", q));
          } };
        }
      );
      D(
        d,
        "Series/Bubble/BubblePoint.js",
        [d["Core/Series/Point.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]],
        function(b, c, h) {
          var a = this && this.__extends || function() {
            var a2 = function(b2, c2) {
              a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
                a3.__proto__ = b3;
              } || function(a3, b3) {
                for (var c3 in b3)
                  b3.hasOwnProperty(c3) && (a3[c3] = b3[c3]);
              };
              return a2(b2, c2);
            };
            return function(b2, c2) {
              function f() {
                this.constructor = b2;
              }
              a2(b2, c2);
              b2.prototype = null === c2 ? Object.create(c2) : (f.prototype = c2.prototype, new f());
            };
          }();
          h = h.extend;
          c = function(c2) {
            function f() {
              var a2 = null !== c2 && c2.apply(this, arguments) || this;
              a2.options = void 0;
              a2.series = void 0;
              return a2;
            }
            a(f, c2);
            f.prototype.haloPath = function(a2) {
              return b.prototype.haloPath.call(this, 0 === a2 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + a2);
            };
            return f;
          }(c.seriesTypes.scatter.prototype.pointClass);
          h(c.prototype, { ttBelow: false });
          return c;
        }
      );
      D(d, "Series/Bubble/BubbleSeries.js", [
        d["Series/Bubble/BubbleLegendComposition.js"],
        d["Series/Bubble/BubblePoint.js"],
        d["Core/Color/Color.js"],
        d["Core/Globals.js"],
        d["Core/Series/SeriesRegistry.js"],
        d["Core/Utilities.js"]
      ], function(b, c, h, a, f, d2) {
        function n() {
          var a2 = this, e2 = this.len, b2 = this.chart, g2 = this.isXAxis, c2 = g2 ? "xData" : "yData", f2 = this.min, k2 = this.max - f2, m2 = 0, d3 = e2, h2 = e2 / k2, l2;
          this.series.forEach(function(e3) {
            if (e3.bubblePadding && (e3.visible || !b2.options.chart.ignoreHiddenSeries)) {
              l2 = a2.allowZoomOutside = true;
              var x = e3[c2];
              g2 && ((e3.onPoint || e3).getRadii(0, 0, e3), e3.onPoint && (e3.radii = e3.onPoint.radii));
              if (0 < k2) {
                for (var B = x.length; B--; )
                  if (N(x[B]) && a2.dataMin <= x[B] && x[B] <= a2.max) {
                    var y = e3.radii && e3.radii[B] || 0;
                    m2 = Math.min((x[B] - f2) * h2 - y, m2);
                    d3 = Math.max((x[B] - f2) * h2 + y, d3);
                  }
              }
            }
          });
          l2 && 0 < k2 && !this.logarithmic && (d3 -= e2, h2 *= (e2 + Math.max(0, m2) - Math.min(d3, e2)) / e2, [["min", "userMin", m2], ["max", "userMax", d3]].forEach(function(e3) {
            "undefined" === typeof L(a2.options[e3[0]], a2[e3[1]]) && (a2[e3[0]] += e3[2] / h2);
          }));
        }
        var w = this && this.__extends || function() {
          var a2 = function(e2, b2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, e3) {
              a3.__proto__ = e3;
            } || function(a3, e3) {
              for (var b3 in e3)
                e3.hasOwnProperty(b3) && (a3[b3] = e3[b3]);
            };
            return a2(e2, b2);
          };
          return function(e2, b2) {
            function g2() {
              this.constructor = e2;
            }
            a2(e2, b2);
            e2.prototype = null === b2 ? Object.create(b2) : (g2.prototype = b2.prototype, new g2());
          };
        }(), q = h.parse;
        h = a.noop;
        var F = f.series, p = f.seriesTypes;
        a = p.column.prototype;
        var l = p.scatter;
        p = d2.addEvent;
        var e = d2.arrayMax, g = d2.arrayMin, k = d2.clamp, m = d2.extend, N = d2.isNumber, G = d2.merge, L = d2.pick, E = [];
        d2 = function(a2) {
          function c2() {
            var e2 = null !== a2 && a2.apply(this, arguments) || this;
            e2.data = void 0;
            e2.maxPxSize = void 0;
            e2.minPxSize = void 0;
            e2.options = void 0;
            e2.points = void 0;
            e2.radii = void 0;
            e2.yData = void 0;
            e2.zData = void 0;
            return e2;
          }
          w(c2, a2);
          c2.compose = function(a3, e2, c3, g2) {
            b.compose(e2, c3, g2);
            -1 === E.indexOf(a3) && (E.push(a3), a3.prototype.beforePadding = n);
          };
          c2.prototype.animate = function(a3) {
            !a3 && this.points.length < this.options.animationLimit && this.points.forEach(function(a4) {
              var e2 = a4.graphic;
              e2 && e2.width && (this.hasRendered || e2.attr({ x: a4.plotX, y: a4.plotY, width: 1, height: 1 }), e2.animate(this.markerAttribs(a4), this.options.animation));
            }, this);
          };
          c2.prototype.getRadii = function() {
            var a3 = this, e2 = this.zData, b2 = this.yData, c3 = [], g2 = this.chart.bubbleZExtremes;
            var f2 = this.getPxExtremes();
            var k2 = f2.minPxSize, m2 = f2.maxPxSize;
            if (!g2) {
              var d3 = Number.MAX_VALUE, h2 = -Number.MAX_VALUE, l2;
              this.chart.series.forEach(function(e3) {
                e3.bubblePadding && (e3.visible || !a3.chart.options.chart.ignoreHiddenSeries) && (e3 = (e3.onPoint || e3).getZExtremes()) && (d3 = Math.min(d3 || e3.zMin, e3.zMin), h2 = Math.max(h2 || e3.zMax, e3.zMax), l2 = true);
              });
              l2 ? (g2 = { zMin: d3, zMax: h2 }, this.chart.bubbleZExtremes = g2) : g2 = { zMin: 0, zMax: 0 };
            }
            var n2 = 0;
            for (f2 = e2.length; n2 < f2; n2++) {
              var v = e2[n2];
              c3.push(this.getRadius(g2.zMin, g2.zMax, k2, m2, v, b2 && b2[n2]));
            }
            this.radii = c3;
          };
          c2.prototype.getRadius = function(a3, e2, b2, c3, g2, f2) {
            var x = this.options, k2 = "width" !== x.sizeBy, m2 = x.zThreshold, d3 = e2 - a3, h2 = 0.5;
            if (null === f2 || null === g2)
              return null;
            if (N(g2)) {
              x.sizeByAbsoluteValue && (g2 = Math.abs(g2 - m2), d3 = Math.max(e2 - m2, Math.abs(a3 - m2)), a3 = 0);
              if (g2 < a3)
                return b2 / 2 - 1;
              0 < d3 && (h2 = (g2 - a3) / d3);
            }
            k2 && 0 <= h2 && (h2 = Math.sqrt(h2));
            return Math.ceil(b2 + h2 * (c3 - b2)) / 2;
          };
          c2.prototype.hasData = function() {
            return !!this.processedXData.length;
          };
          c2.prototype.pointAttribs = function(a3, e2) {
            var b2 = this.options.marker.fillOpacity;
            a3 = F.prototype.pointAttribs.call(this, a3, e2);
            1 !== b2 && (a3.fill = q(a3.fill).setOpacity(b2).get("rgba"));
            return a3;
          };
          c2.prototype.translate = function() {
            a2.prototype.translate.call(this);
            this.getRadii();
            this.translateBubble();
          };
          c2.prototype.translateBubble = function() {
            for (var a3 = this.data, e2 = this.radii, b2 = this.getPxExtremes().minPxSize, c3 = a3.length; c3--; ) {
              var g2 = a3[c3], f2 = e2 ? e2[c3] : 0;
              N(f2) && f2 >= b2 / 2 ? (g2.marker = m(g2.marker, { radius: f2, width: 2 * f2, height: 2 * f2 }), g2.dlBox = { x: g2.plotX - f2, y: g2.plotY - f2, width: 2 * f2, height: 2 * f2 }) : (g2.shapeArgs = g2.plotY = g2.dlBox = void 0, g2.isInside = false);
            }
          };
          c2.prototype.getPxExtremes = function() {
            var a3 = Math.min(
              this.chart.plotWidth,
              this.chart.plotHeight
            ), e2 = function(e3) {
              if ("string" === typeof e3) {
                var b3 = /%$/.test(e3);
                e3 = parseInt(e3, 10);
              }
              return b3 ? a3 * e3 / 100 : e3;
            }, b2 = e2(L(this.options.minSize, 8));
            e2 = Math.max(e2(L(this.options.maxSize, "20%")), b2);
            return { minPxSize: b2, maxPxSize: e2 };
          };
          c2.prototype.getZExtremes = function() {
            var a3 = this.options, b2 = (this.zData || []).filter(N);
            if (b2.length) {
              var c3 = L(a3.zMin, k(g(b2), false === a3.displayNegative ? a3.zThreshold || 0 : -Number.MAX_VALUE, Number.MAX_VALUE));
              a3 = L(a3.zMax, e(b2));
              if (N(c3) && N(a3))
                return { zMin: c3, zMax: a3 };
            }
          };
          c2.defaultOptions = G(
            l.defaultOptions,
            { dataLabels: { formatter: function() {
              var a3 = this.series.chart.numberFormatter, e2 = this.point.z;
              return N(e2) ? a3(e2, -1) : "";
            }, inside: true, verticalAlign: "middle" }, animationLimit: 250, marker: { lineColor: null, lineWidth: 1, fillOpacity: 0.5, radius: null, states: { hover: { radiusPlus: 0 } }, symbol: "circle" }, minSize: 8, maxSize: "20%", softThreshold: false, states: { hover: { halo: { size: 5 } } }, tooltip: { pointFormat: "({point.x}, {point.y}), Size: {point.z}" }, turboThreshold: 0, zThreshold: 0, zoneAxis: "z" }
          );
          return c2;
        }(l);
        m(d2.prototype, {
          alignDataLabel: a.alignDataLabel,
          applyZones: h,
          bubblePadding: true,
          buildKDTree: h,
          directTouch: true,
          isBubble: true,
          pointArrayMap: ["y", "z"],
          pointClass: c,
          parallelArrays: ["x", "y", "z"],
          trackerGroups: ["group", "dataLabelsGroup"],
          specialGroup: "group",
          zoneAxis: "z"
        });
        p(d2, "updatedData", function(a2) {
          delete a2.target.chart.bubbleZExtremes;
        });
        p(d2, "remove", function(a2) {
          delete a2.target.chart.bubbleZExtremes;
        });
        f.registerSeriesType("bubble", d2);
        "";
        "";
        return d2;
      });
      D(
        d,
        "Series/ColumnRange/ColumnRangePoint.js",
        [d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]],
        function(b, c) {
          var h = this && this.__extends || function() {
            var a2 = function(b2, c2) {
              a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
                a3.__proto__ = b3;
              } || function(a3, b3) {
                for (var c3 in b3)
                  b3.hasOwnProperty(c3) && (a3[c3] = b3[c3]);
              };
              return a2(b2, c2);
            };
            return function(b2, c2) {
              function f2() {
                this.constructor = b2;
              }
              a2(b2, c2);
              b2.prototype = null === c2 ? Object.create(c2) : (f2.prototype = c2.prototype, new f2());
            };
          }(), a = b.seriesTypes;
          b = a.column.prototype.pointClass.prototype;
          var f = c.extend, d2 = c.isNumber;
          c = function(a2) {
            function b2() {
              var b3 = null !== a2 && a2.apply(this, arguments) || this;
              b3.options = void 0;
              b3.series = void 0;
              return b3;
            }
            h(b2, a2);
            b2.prototype.isValid = function() {
              return d2(this.low);
            };
            return b2;
          }(a.arearange.prototype.pointClass);
          f(c.prototype, { setState: b.setState });
          return c;
        }
      );
      D(d, "Series/ColumnRange/ColumnRangeSeries.js", [d["Series/ColumnRange/ColumnRangePoint.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(b, c, d2, a) {
        var f = this && this.__extends || function() {
          var a2 = function(e2, b2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, e3) {
              a3.__proto__ = e3;
            } || function(a3, e3) {
              for (var b3 in e3)
                e3.hasOwnProperty(b3) && (a3[b3] = e3[b3]);
            };
            return a2(e2, b2);
          };
          return function(e2, b2) {
            function c2() {
              this.constructor = e2;
            }
            a2(e2, b2);
            e2.prototype = null === b2 ? Object.create(b2) : (c2.prototype = b2.prototype, new c2());
          };
        }();
        c = c.noop;
        var h = d2.seriesTypes, n = h.arearange, r = h.column, q = h.column.prototype, F = a.clamp;
        h = a.extend;
        var p = a.isNumber, l = a.merge, e = a.pick, g = { pointRange: null, marker: null, states: { hover: { halo: false } } };
        a = function(a2) {
          function b2() {
            return null !== a2 && a2.apply(this, arguments) || this;
          }
          f(b2, a2);
          b2.prototype.setOptions = function() {
            l(true, arguments[0], { stacking: void 0 });
            return n.prototype.setOptions.apply(this, arguments);
          };
          b2.prototype.translate = function() {
            var a3 = this, b3 = this.yAxis, c2 = this.xAxis, g2 = c2.startAngleRad, f2 = this.chart, k = this.xAxis.isRadial, d3 = Math.max(f2.chartWidth, f2.chartHeight) + 999, h2, x, m, l2;
            q.translate.apply(this);
            this.points.forEach(function(B) {
              var t = B.shapeArgs || {}, y = a3.options.minPointLength, n2 = B.plotY, H = b3.translate(B.high, 0, 1, 0, 1);
              p(H) && p(n2) && (B.plotHigh = F(H, -d3, d3), B.plotLow = F(
                n2,
                -d3,
                d3
              ), l2 = B.plotHigh, h2 = e(B.rectPlotY, B.plotY) - B.plotHigh, Math.abs(h2) < y ? (x = y - h2, h2 += x, l2 -= x / 2) : 0 > h2 && (h2 *= -1, l2 -= h2), k && a3.polar ? (m = B.barX + g2, B.shapeType = "arc", B.shapeArgs = a3.polar.arc(l2 + h2, l2, m, m + B.pointWidth)) : (t.height = h2, t.y = l2, y = t.x, y = void 0 === y ? 0 : y, t = t.width, t = void 0 === t ? 0 : t, B.tooltipPos = f2.inverted ? [b3.len + b3.pos - f2.plotLeft - l2 - h2 / 2, c2.len + c2.pos - f2.plotTop - y - t / 2, h2] : [c2.left - f2.plotLeft + y + t / 2, b3.pos - f2.plotTop + l2 + h2 / 2, h2]));
            });
          };
          b2.prototype.pointAttribs = function() {
            return q.pointAttribs.apply(this, arguments);
          };
          b2.prototype.translate3dPoints = function() {
            return q.translate3dPoints.apply(this, arguments);
          };
          b2.prototype.translate3dShapes = function() {
            return q.translate3dShapes.apply(this, arguments);
          };
          b2.defaultOptions = l(r.defaultOptions, n.defaultOptions, g);
          return b2;
        }(n);
        h(a.prototype, { directTouch: true, pointClass: b, trackerGroups: ["group", "dataLabelsGroup"], adjustForMissingColumns: q.adjustForMissingColumns, animate: q.animate, crispCol: q.crispCol, drawGraph: c, drawPoints: q.drawPoints, getSymbol: c, drawTracker: q.drawTracker, getColumnMetrics: q.getColumnMetrics });
        d2.registerSeriesType("columnrange", a);
        "";
        return a;
      });
      D(d, "Series/ColumnPyramid/ColumnPyramidSeries.js", [d["Series/Column/ColumnSeries.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(b, c, h) {
        var a = this && this.__extends || function() {
          var a2 = function(b2, c2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, e) {
              a3.__proto__ = e;
            } || function(a3, e) {
              for (var b3 in e)
                e.hasOwnProperty(b3) && (a3[b3] = e[b3]);
            };
            return a2(b2, c2);
          };
          return function(b2, c2) {
            function f2() {
              this.constructor = b2;
            }
            a2(b2, c2);
            b2.prototype = null === c2 ? Object.create(c2) : (f2.prototype = c2.prototype, new f2());
          };
        }(), f = b.prototype, d2 = h.clamp, n = h.merge, r = h.pick;
        h = function(c2) {
          function h2() {
            var a2 = null !== c2 && c2.apply(this, arguments) || this;
            a2.data = void 0;
            a2.options = void 0;
            a2.points = void 0;
            return a2;
          }
          a(h2, c2);
          h2.prototype.translate = function() {
            var a2 = this, b2 = a2.chart, e = a2.options, c3 = a2.dense = 2 > a2.closestPointRange * a2.xAxis.transA;
            c3 = a2.borderWidth = r(e.borderWidth, c3 ? 0 : 1);
            var k = a2.yAxis, h3 = e.threshold, n2 = a2.translatedThreshold = k.getThreshold(h3), G = r(e.minPointLength, 5), w = a2.getColumnMetrics(), E = w.width, v = a2.barW = Math.max(E, 1 + 2 * c3), q = a2.pointXOffset = w.offset;
            b2.inverted && (n2 -= 0.5);
            e.pointPadding && (v = Math.ceil(v));
            f.translate.apply(a2);
            a2.points.forEach(function(c4) {
              var g = r(c4.yBottom, n2), f2 = 999 + Math.abs(g), m = d2(c4.plotY, -f2, k.len + f2);
              f2 = c4.plotX + q;
              var y = v / 2, l = Math.min(m, g);
              g = Math.max(m, g) - l;
              var t;
              c4.barX = f2;
              c4.pointWidth = E;
              c4.tooltipPos = b2.inverted ? [k.len + k.pos - b2.plotLeft - m, a2.xAxis.len - f2 - y, g] : [f2 + y, m + k.pos - b2.plotTop, g];
              m = h3 + (c4.total || c4.y);
              "percent" === e.stacking && (m = h3 + (0 > c4.y) ? -100 : 100);
              m = k.toPixels(m, true);
              var J = (t = b2.plotHeight - m - (b2.plotHeight - n2)) ? y * (l - m) / t : 0;
              var w2 = t ? y * (l + g - m) / t : 0;
              t = f2 - J + y;
              J = f2 + J + y;
              var p = f2 + w2 + y;
              w2 = f2 - w2 + y;
              var A = l - G;
              var F = l + g;
              0 > c4.y && (A = l, F = l + g + G);
              b2.inverted && (p = k.width - l, t = m - (k.width - n2), J = y * (m - p) / t, w2 = y * (m - (p - g)) / t, t = f2 + y + J, J = t - 2 * J, p = f2 - w2 + y, w2 = f2 + w2 + y, A = l, F = l + g - G, 0 > c4.y && (F = l + g + G));
              c4.shapeType = "path";
              c4.shapeArgs = { x: t, y: A, width: J - t, height: g, d: [["M", t, A], ["L", J, A], ["L", p, F], ["L", w2, F], ["Z"]] };
            });
          };
          h2.defaultOptions = n(b.defaultOptions, {});
          return h2;
        }(b);
        c.registerSeriesType("columnpyramid", h);
        "";
        return h;
      });
      D(
        d,
        "Series/ErrorBar/ErrorBarSeriesDefaults.js",
        [],
        function() {
          "";
          return { color: "#000000", grouping: false, linkedTo: ":previous", tooltip: { pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>' }, whiskerWidth: null };
        }
      );
      D(d, "Series/ErrorBar/ErrorBarSeries.js", [d["Series/BoxPlot/BoxPlotSeries.js"], d["Series/Column/ColumnSeries.js"], d["Series/ErrorBar/ErrorBarSeriesDefaults.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(b, c, h, a, f) {
        var d2 = this && this.__extends || function() {
          var a2 = function(b2, e) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, e2) {
              a3.__proto__ = e2;
            } || function(a3, e2) {
              for (var b3 in e2)
                e2.hasOwnProperty(b3) && (a3[b3] = e2[b3]);
            };
            return a2(b2, e);
          };
          return function(b2, e) {
            function c2() {
              this.constructor = b2;
            }
            a2(b2, e);
            b2.prototype = null === e ? Object.create(e) : (c2.prototype = e.prototype, new c2());
          };
        }(), n = a.seriesTypes.arearange, r = f.addEvent, q = f.merge;
        f = f.extend;
        var F = function(a2) {
          function f2() {
            var e = null !== a2 && a2.apply(this, arguments) || this;
            e.data = void 0;
            e.options = void 0;
            e.points = void 0;
            return e;
          }
          d2(f2, a2);
          f2.prototype.getColumnMetrics = function() {
            return this.linkedParent && this.linkedParent.columnMetrics || c.prototype.getColumnMetrics.call(this);
          };
          f2.prototype.drawDataLabels = function() {
            var a3 = this.pointValKey;
            n && (n.prototype.drawDataLabels.call(this), this.data.forEach(function(e) {
              e.y = e[a3];
            }));
          };
          f2.prototype.toYData = function(a3) {
            return [a3.low, a3.high];
          };
          f2.defaultOptions = q(b.defaultOptions, h);
          return f2;
        }(b);
        r(F, "afterTranslate", function() {
          this.points.forEach(function(a2) {
            a2.plotLow = a2.plotY;
          });
        }, { order: 0 });
        f(F.prototype, { pointArrayMap: ["low", "high"], pointValKey: "high", doQuartiles: false });
        a.registerSeriesType("errorbar", F);
        return F;
      });
      D(d, "Series/Gauge/GaugePoint.js", [d["Core/Series/SeriesRegistry.js"]], function(b) {
        var c = this && this.__extends || function() {
          var b2 = function(a, c2) {
            b2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a2, b3) {
              a2.__proto__ = b3;
            } || function(a2, b3) {
              for (var c3 in b3)
                b3.hasOwnProperty(c3) && (a2[c3] = b3[c3]);
            };
            return b2(a, c2);
          };
          return function(a, c2) {
            function f() {
              this.constructor = a;
            }
            b2(a, c2);
            a.prototype = null === c2 ? Object.create(c2) : (f.prototype = c2.prototype, new f());
          };
        }();
        return function(b2) {
          function a() {
            var a2 = null !== b2 && b2.apply(this, arguments) || this;
            a2.options = void 0;
            a2.series = void 0;
            a2.shapeArgs = void 0;
            return a2;
          }
          c(a, b2);
          a.prototype.setState = function(a2) {
            this.state = a2;
          };
          return a;
        }(b.series.prototype.pointClass);
      });
      D(d, "Series/Gauge/GaugeSeries.js", [d["Series/Gauge/GaugePoint.js"], d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]], function(b, c, h, a) {
        var f = this && this.__extends || function() {
          var a2 = function(e2, b2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, e3) {
              a3.__proto__ = e3;
            } || function(a3, e3) {
              for (var b3 in e3)
                e3.hasOwnProperty(b3) && (a3[b3] = e3[b3]);
            };
            return a2(e2, b2);
          };
          return function(e2, b2) {
            function c2() {
              this.constructor = e2;
            }
            a2(e2, b2);
            e2.prototype = null === b2 ? Object.create(b2) : (c2.prototype = b2.prototype, new c2());
          };
        }();
        c = c.noop;
        var d2 = h.series, n = h.seriesTypes.column, r = a.clamp, q = a.isNumber, F = a.extend, p = a.merge, l = a.pick, e = a.pInt;
        a = function(a2) {
          function b2() {
            var e2 = null !== a2 && a2.apply(this, arguments) || this;
            e2.data = void 0;
            e2.points = void 0;
            e2.options = void 0;
            e2.yAxis = void 0;
            return e2;
          }
          f(b2, a2);
          b2.prototype.translate = function() {
            var a3 = this.yAxis, b3 = this.options, c2 = a3.center;
            this.generatePoints();
            this.points.forEach(function(g) {
              var f2 = p(b3.dial, g.dial), d3 = e(f2.radius) * c2[2] / 200, h2 = e(f2.baseLength) * d3 / 100, k = e(f2.rearLength) * d3 / 100, m = f2.baseWidth, x = f2.topWidth, B = b3.overshoot, y = a3.startAngleRad + a3.translate(g.y, void 0, void 0, void 0, true);
              if (q(B) || false === b3.wrap)
                B = q(B) ? B / 180 * Math.PI : 0, y = r(y, a3.startAngleRad - B, a3.endAngleRad + B);
              y = 180 * y / Math.PI;
              g.shapeType = "path";
              g.shapeArgs = { d: f2.path || [["M", -k, -m / 2], ["L", h2, -m / 2], ["L", d3, -x / 2], ["L", d3, x / 2], ["L", h2, m / 2], ["L", -k, m / 2], ["Z"]], translateX: c2[0], translateY: c2[1], rotation: y };
              g.plotX = c2[0];
              g.plotY = c2[1];
            });
          };
          b2.prototype.drawPoints = function() {
            var a3 = this, e2 = a3.chart, b3 = a3.yAxis.center, c2 = a3.pivot, g = a3.options, f2 = g.pivot, d3 = e2.renderer;
            a3.points.forEach(function(b4) {
              var c3 = b4.graphic, f3 = b4.shapeArgs, h2 = f3.d, k = p(g.dial, b4.dial);
              c3 ? (c3.animate(f3), f3.d = h2) : b4.graphic = d3[b4.shapeType](f3).attr({ rotation: f3.rotation, zIndex: 1 }).addClass("highcharts-dial").add(a3.group);
              if (!e2.styledMode)
                b4.graphic[c3 ? "animate" : "attr"]({ stroke: k.borderColor, "stroke-width": k.borderWidth, fill: k.backgroundColor });
            });
            c2 ? c2.animate({ translateX: b3[0], translateY: b3[1] }) : f2 && (a3.pivot = d3.circle(0, 0, f2.radius).attr({ zIndex: 2 }).addClass("highcharts-pivot").translate(b3[0], b3[1]).add(a3.group), e2.styledMode || a3.pivot.attr({ fill: f2.backgroundColor, stroke: f2.borderColor, "stroke-width": f2.borderWidth }));
          };
          b2.prototype.animate = function(a3) {
            var e2 = this;
            a3 || e2.points.forEach(function(a4) {
              var b3 = a4.graphic;
              b3 && (b3.attr({ rotation: 180 * e2.yAxis.startAngleRad / Math.PI }), b3.animate({ rotation: a4.shapeArgs.rotation }, e2.options.animation));
            });
          };
          b2.prototype.render = function() {
            this.group = this.plotGroup("group", "series", this.visible ? "inherit" : "hidden", this.options.zIndex, this.chart.seriesGroup);
            d2.prototype.render.call(this);
            this.group.clip(this.chart.clipRect);
          };
          b2.prototype.setData = function(a3, e2) {
            d2.prototype.setData.call(this, a3, false);
            this.processData();
            this.generatePoints();
            l(e2, true) && this.chart.redraw();
          };
          b2.prototype.hasData = function() {
            return !!this.points.length;
          };
          b2.defaultOptions = p(d2.defaultOptions, { dataLabels: { borderColor: "#cccccc", borderRadius: 3, borderWidth: 1, crop: false, defer: false, enabled: true, verticalAlign: "top", y: 15, zIndex: 2 }, dial: { backgroundColor: "#000000", baseLength: "70%", baseWidth: 3, borderColor: "#cccccc", borderWidth: 0, radius: "80%", rearLength: "10%", topWidth: 1 }, pivot: { radius: 5, borderWidth: 0, borderColor: "#cccccc", backgroundColor: "#000000" }, tooltip: { headerFormat: "" }, showInLegend: false });
          return b2;
        }(d2);
        F(a.prototype, {
          angular: true,
          directTouch: true,
          drawGraph: c,
          drawTracker: n.prototype.drawTracker,
          fixedBox: true,
          forceDL: true,
          noSharedTooltip: true,
          pointClass: b,
          trackerGroups: ["group", "dataLabelsGroup"]
        });
        h.registerSeriesType("gauge", a);
        "";
        return a;
      });
      D(d, "Series/DragNodesComposition.js", [d["Core/Utilities.js"]], function(b) {
        function c() {
          var a2 = this, b2, c2, h;
          a2.container && (b2 = d2(a2.container, "mousedown", function(b3) {
            var f = a2.hoverPoint;
            f && f.series && f.series.hasDraggableNodes && f.series.options.draggable && (f.series.onMouseDown(f, b3), c2 = d2(a2.container, "mousemove", function(a3) {
              return f && f.series && f.series.onMouseMove(
                f,
                a3
              );
            }), h = d2(a2.container.ownerDocument, "mouseup", function(a3) {
              c2();
              h();
              return f && f.series && f.series.onMouseUp(f, a3);
            }));
          }));
          d2(a2, "destroy", function() {
            b2();
          });
        }
        var d2 = b.addEvent, a = [];
        return {
          compose: function(b2) {
            -1 === a.indexOf(b2) && (a.push(b2), d2(b2, "load", c));
          },
          onMouseDown: function(a2, b2) {
            b2 = this.chart.pointer.normalize(b2);
            a2.fixedPosition = { chartX: b2.chartX, chartY: b2.chartY, plotX: a2.plotX, plotY: a2.plotY };
            a2.inDragMode = true;
          },
          onMouseMove: function(a2, b2) {
            if (a2.fixedPosition && a2.inDragMode) {
              var c2 = this.chart, f = c2.pointer.normalize(b2);
              b2 = a2.fixedPosition.chartX - f.chartX;
              f = a2.fixedPosition.chartY - f.chartY;
              var d3 = c2.graphLayoutsLookup, h = void 0, w = void 0;
              if (5 < Math.abs(b2) || 5 < Math.abs(f))
                h = a2.fixedPosition.plotX - b2, w = a2.fixedPosition.plotY - f, c2.isInsidePlot(h, w) && (a2.plotX = h, a2.plotY = w, a2.hasDragged = true, this.redrawHalo(a2), d3.forEach(function(a3) {
                  a3.restartSimulation();
                }));
            }
          },
          onMouseUp: function(a2, b2) {
            a2.fixedPosition && (a2.hasDragged && (this.layout.enableSimulation ? this.layout.start() : this.chart.redraw()), a2.inDragMode = a2.hasDragged = false, this.options.fixedDraggable || delete a2.fixedPosition);
          },
          redrawHalo: function(a2) {
            a2 && this.halo && this.halo.attr({ d: a2.haloPath(this.options.states.hover.halo.size) });
          }
        };
      });
      D(d, "Series/GraphLayoutComposition.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Utilities.js"]], function(b, c) {
        function d2() {
          this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function(a2) {
            a2.updateSimulation();
          }), this.redraw());
        }
        function a() {
          this.graphLayoutsLookup && (this.graphLayoutsLookup.forEach(function(a2) {
            a2.updateSimulation(false);
          }), this.redraw());
        }
        function f() {
          this.graphLayoutsLookup && this.graphLayoutsLookup.forEach(function(a2) {
            a2.stop();
          });
        }
        function w() {
          var a2 = false, b2 = function(e) {
            e.maxIterations-- && isFinite(e.temperature) && !e.isStable() && !e.enableSimulation && (e.beforeStep && e.beforeStep(), e.step(), c2 = false, a2 = true);
          };
          if (this.graphLayoutsLookup) {
            n(false, this);
            for (this.graphLayoutsLookup.forEach(function(a3) {
              return a3.start();
            }); !c2; ) {
              var c2 = true;
              this.graphLayoutsLookup.forEach(b2);
            }
            a2 && this.series.forEach(function(a3) {
              a3 && a3.layout && a3.render();
            });
          }
        }
        var n = b.setAnimation, r = c.addEvent, q = [];
        return { compose: function(b2) {
          q.indexOf(b2) && (q.push(b2), r(b2, "afterPrint", d2), r(b2, "beforePrint", a), r(b2, "predraw", f), r(b2, "render", w));
        }, integrations: {}, layouts: {} };
      });
      D(d, "Series/PackedBubble/PackedBubblePoint.js", [d["Core/Chart/Chart.js"], d["Core/Series/Point.js"], d["Core/Series/SeriesRegistry.js"]], function(b, c, d2) {
        var a = this && this.__extends || function() {
          var a2 = function(b2, c2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
              a3.__proto__ = b3;
            } || function(a3, b3) {
              for (var c3 in b3)
                b3.hasOwnProperty(c3) && (a3[c3] = b3[c3]);
            };
            return a2(b2, c2);
          };
          return function(b2, c2) {
            function f() {
              this.constructor = b2;
            }
            a2(b2, c2);
            b2.prototype = null === c2 ? Object.create(c2) : (f.prototype = c2.prototype, new f());
          };
        }();
        return function(f) {
          function d3() {
            var a2 = null !== f && f.apply(this, arguments) || this;
            a2.degree = NaN;
            a2.mass = NaN;
            a2.radius = NaN;
            a2.options = void 0;
            a2.series = void 0;
            a2.value = null;
            return a2;
          }
          a(d3, f);
          d3.prototype.destroy = function() {
            this.series.layout && this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);
            return c.prototype.destroy.apply(this, arguments);
          };
          d3.prototype.firePointEvent = function() {
            var a2 = this.series.options;
            if (this.isParentNode && a2.parentNode) {
              var b2 = a2.allowPointSelect;
              a2.allowPointSelect = a2.parentNode.allowPointSelect;
              c.prototype.firePointEvent.apply(this, arguments);
              a2.allowPointSelect = b2;
            } else
              c.prototype.firePointEvent.apply(this, arguments);
          };
          d3.prototype.select = function() {
            var a2 = this.series.chart;
            this.isParentNode ? (a2.getSelectedPoints = a2.getSelectedParentNodes, c.prototype.select.apply(this, arguments), a2.getSelectedPoints = b.prototype.getSelectedPoints) : c.prototype.select.apply(this, arguments);
          };
          return d3;
        }(d2.seriesTypes.bubble.prototype.pointClass);
      });
      D(d, "Series/PackedBubble/PackedBubbleSeriesDefaults.js", [d["Core/Utilities.js"]], function(b) {
        var c = b.isNumber;
        "";
        return { minSize: "10%", maxSize: "50%", sizeBy: "area", zoneAxis: "y", crisp: false, tooltip: { pointFormat: "Value: {point.value}" }, draggable: true, useSimulation: true, parentNode: { allowPointSelect: false }, dataLabels: {
          formatter: function() {
            var b2 = this.series.chart.numberFormatter, a = this.point.value;
            return c(a) ? b2(a, -1) : "";
          },
          parentNodeFormatter: function() {
            return this.name;
          },
          parentNodeTextPath: { enabled: true },
          padding: 0,
          style: { transition: "opacity 2000ms" }
        }, layoutAlgorithm: {
          initialPositions: "circle",
          initialPositionRadius: 20,
          bubblePadding: 5,
          parentNodeLimit: false,
          seriesInteraction: true,
          dragBetweenSeries: false,
          parentNodeOptions: { maxIterations: 400, gravitationalConstant: 0.03, maxSpeed: 50, initialPositionRadius: 100, seriesInteraction: true, marker: { fillColor: null, fillOpacity: 1, lineWidth: null, lineColor: null, symbol: "circle" } },
          enableSimulation: true,
          type: "packedbubble",
          integration: "packedbubble",
          maxIterations: 1e3,
          splitSeries: false,
          maxSpeed: 5,
          gravitationalConstant: 0.01,
          friction: -0.981
        } };
      });
      D(d, "Series/Networkgraph/VerletIntegration.js", [], function() {
        return { attractive: function(b, c, d2) {
          var a = b.getMass(), f = -d2.x * c * this.diffTemperature;
          c = -d2.y * c * this.diffTemperature;
          b.fromNode.fixedPosition || (b.fromNode.plotX -= f * a.fromNode / b.fromNode.degree, b.fromNode.plotY -= c * a.fromNode / b.fromNode.degree);
          b.toNode.fixedPosition || (b.toNode.plotX += f * a.toNode / b.toNode.degree, b.toNode.plotY += c * a.toNode / b.toNode.degree);
        }, attractiveForceFunction: function(b, c) {
          return (c - b) / b;
        }, barycenter: function() {
          var b = this.options.gravitationalConstant, c = this.barycenter.xFactor, d2 = this.barycenter.yFactor;
          c = (c - (this.box.left + this.box.width) / 2) * b;
          d2 = (d2 - (this.box.top + this.box.height) / 2) * b;
          this.nodes.forEach(function(a) {
            a.fixedPosition || (a.plotX -= c / a.mass / a.degree, a.plotY -= d2 / a.mass / a.degree);
          });
        }, getK: function(b) {
          return Math.pow(b.box.width * b.box.height / b.nodes.length, 0.5);
        }, integrate: function(b, c) {
          var d2 = -b.options.friction, a = b.options.maxSpeed, f = (c.plotX + c.dispX - c.prevX) * d2;
          d2 *= c.plotY + c.dispY - c.prevY;
          var w = Math.abs, n = w(f) / (f || 1);
          w = w(d2) / (d2 || 1);
          f = n * Math.min(a, Math.abs(f));
          d2 = w * Math.min(a, Math.abs(d2));
          c.prevX = c.plotX + c.dispX;
          c.prevY = c.plotY + c.dispY;
          c.plotX += f;
          c.plotY += d2;
          c.temperature = b.vectorLength({ x: f, y: d2 });
        }, repulsive: function(b, c, d2) {
          c = c * this.diffTemperature / b.mass / b.degree;
          b.fixedPosition || (b.plotX += d2.x * c, b.plotY += d2.y * c);
        }, repulsiveForceFunction: function(b, c) {
          return (c - b) / b * (c > b ? 1 : 0);
        } };
      });
      D(
        d,
        "Series/PackedBubble/PackedBubbleIntegration.js",
        [d["Core/Globals.js"], d["Series/Networkgraph/VerletIntegration.js"]],
        function(b, c) {
          return { barycenter: function() {
            for (var b2 = this.options.gravitationalConstant, a = this.box, c2 = this.nodes, d2, n, r = 0; r < c2.length; r++) {
              var q = c2[r];
              this.options.splitSeries && !q.isParentNode ? (d2 = q.series.parentNode.plotX, n = q.series.parentNode.plotY) : (d2 = a.width / 2, n = a.height / 2);
              q.fixedPosition || (q.plotX -= (q.plotX - d2) * b2 / (q.mass * Math.sqrt(c2.length)), q.plotY -= (q.plotY - n) * b2 / (q.mass * Math.sqrt(c2.length)));
            }
          }, getK: b.noop, integrate: c.integrate, repulsive: function(b2, a, c2, d2) {
            var f = a * this.diffTemperature / b2.mass / b2.degree;
            a = c2.x * f;
            c2 = c2.y * f;
            b2.fixedPosition || (b2.plotX += a, b2.plotY += c2);
            d2.fixedPosition || (d2.plotX -= a, d2.plotY -= c2);
          }, repulsiveForceFunction: function(b2, a, c2, d2) {
            return Math.min(b2, (c2.marker.radius + d2.marker.radius) / 2);
          } };
        }
      );
      D(d, "Series/Networkgraph/EulerIntegration.js", [], function() {
        return { attractive: function(b, c, d2, a) {
          var f = b.getMass(), h = d2.x / a * c;
          c *= d2.y / a;
          b.fromNode.fixedPosition || (b.fromNode.dispX -= h * f.fromNode / b.fromNode.degree, b.fromNode.dispY -= c * f.fromNode / b.fromNode.degree);
          b.toNode.fixedPosition || (b.toNode.dispX += h * f.toNode / b.toNode.degree, b.toNode.dispY += c * f.toNode / b.toNode.degree);
        }, attractiveForceFunction: function(b, c) {
          return b * b / c;
        }, barycenter: function() {
          var b = this.options.gravitationalConstant, c = this.barycenter.xFactor, d2 = this.barycenter.yFactor;
          this.nodes.forEach(function(a) {
            if (!a.fixedPosition) {
              var f = a.getDegree();
              f *= 1 + f / 2;
              a.dispX += (c - a.plotX) * b * f / a.degree;
              a.dispY += (d2 - a.plotY) * b * f / a.degree;
            }
          });
        }, getK: function(b) {
          return Math.pow(b.box.width * b.box.height / b.nodes.length, 0.3);
        }, integrate: function(b, c) {
          c.dispX += c.dispX * b.options.friction;
          c.dispY += c.dispY * b.options.friction;
          var d2 = c.temperature = b.vectorLength({ x: c.dispX, y: c.dispY });
          0 !== d2 && (c.plotX += c.dispX / d2 * Math.min(Math.abs(c.dispX), b.temperature), c.plotY += c.dispY / d2 * Math.min(Math.abs(c.dispY), b.temperature));
        }, repulsive: function(b, c, d2, a) {
          b.dispX += d2.x / a * c / b.degree;
          b.dispY += d2.y / a * c / b.degree;
        }, repulsiveForceFunction: function(b, c) {
          return c * c / b;
        } };
      });
      D(d, "Series/Networkgraph/QuadTreeNode.js", [], function() {
        return function() {
          function b(b2) {
            this.isInternal = this.isEmpty = this.body = false;
            this.nodes = [];
            this.box = b2;
            this.boxSize = Math.min(b2.width, b2.height);
          }
          b.prototype.divideBox = function() {
            var c = this.box.width / 2, d2 = this.box.height / 2;
            this.nodes[0] = new b({ left: this.box.left, top: this.box.top, width: c, height: d2 });
            this.nodes[1] = new b({ left: this.box.left + c, top: this.box.top, width: c, height: d2 });
            this.nodes[2] = new b({ left: this.box.left + c, top: this.box.top + d2, width: c, height: d2 });
            this.nodes[3] = new b({ left: this.box.left, top: this.box.top + d2, width: c, height: d2 });
          };
          b.prototype.getBoxPosition = function(b2) {
            var c = b2.plotY < this.box.top + this.box.height / 2;
            return b2.plotX < this.box.left + this.box.width / 2 ? c ? 0 : 3 : c ? 1 : 2;
          };
          b.prototype.insert = function(c, d2) {
            this.isInternal ? this.nodes[this.getBoxPosition(c)].insert(c, d2 - 1) : (this.isEmpty = false, this.body ? d2 ? (this.isInternal = true, this.divideBox(), true !== this.body && (this.nodes[this.getBoxPosition(this.body)].insert(this.body, d2 - 1), this.body = true), this.nodes[this.getBoxPosition(c)].insert(c, d2 - 1)) : (d2 = new b({ top: c.plotX || NaN, left: c.plotY || NaN, width: 0.1, height: 0.1 }), d2.body = c, d2.isInternal = false, this.nodes.push(d2)) : (this.isInternal = false, this.body = c));
          };
          b.prototype.updateMassAndCenter = function() {
            var b2 = 0, d2 = 0, a = 0;
            if (this.isInternal) {
              for (var f = 0, w = this.nodes; f < w.length; f++) {
                var n = w[f];
                n.isEmpty || (b2 += n.mass, d2 += n.plotX * n.mass, a += n.plotY * n.mass);
              }
              d2 /= b2;
              a /= b2;
            } else
              this.body && (b2 = this.body.mass, d2 = this.body.plotX, a = this.body.plotY);
            this.mass = b2;
            this.plotX = d2;
            this.plotY = a;
          };
          return b;
        }();
      });
      D(d, "Series/Networkgraph/QuadTree.js", [d["Series/Networkgraph/QuadTreeNode.js"]], function(b) {
        return function() {
          function c(c2, a, d2, w) {
            this.box = {
              left: c2,
              top: a,
              width: d2,
              height: w
            };
            this.maxDepth = 25;
            this.root = new b(this.box);
            this.root.isInternal = true;
            this.root.isRoot = true;
            this.root.divideBox();
          }
          c.prototype.calculateMassAndCenter = function() {
            this.visitNodeRecursive(null, null, function(b2) {
              b2.updateMassAndCenter();
            });
          };
          c.prototype.insertNodes = function(b2) {
            for (var a = 0; a < b2.length; a++)
              this.root.insert(b2[a], this.maxDepth);
          };
          c.prototype.visitNodeRecursive = function(b2, a, c2) {
            var d2;
            b2 || (b2 = this.root);
            b2 === this.root && a && (d2 = a(b2));
            if (false !== d2) {
              for (var f = 0, h = b2.nodes; f < h.length; f++) {
                var q = h[f];
                if (q.isInternal) {
                  a && (d2 = a(q));
                  if (false === d2)
                    continue;
                  this.visitNodeRecursive(q, a, c2);
                } else
                  q.body && a && a(q.body);
                c2 && c2(q);
              }
              b2 === this.root && c2 && c2(b2);
            }
          };
          return c;
        }();
      });
      D(d, "Series/Networkgraph/ReingoldFruchtermanLayout.js", [d["Series/Networkgraph/EulerIntegration.js"], d["Core/Globals.js"], d["Series/GraphLayoutComposition.js"], d["Series/Networkgraph/QuadTree.js"], d["Core/Utilities.js"], d["Series/Networkgraph/VerletIntegration.js"]], function(b, c, d2, a, f, w) {
        var h = c.win, r = f.clamp, q = f.defined, F = f.isFunction, p = f.pick;
        return function() {
          function c2() {
            this.attractiveForce = void 0;
            this.box = {};
            this.currentStep = 0;
            this.initialRendering = true;
            this.integration = void 0;
            this.links = [];
            this.nodes = [];
            this.repulsiveForce = this.quadTree = this.options = void 0;
            this.series = [];
            this.simulation = false;
          }
          c2.compose = function(a2) {
            d2.compose(a2);
            d2.integrations.euler = b;
            d2.integrations.verlet = w;
            d2.layouts["reingold-fruchterman"] = c2;
          };
          c2.prototype.init = function(a2) {
            this.options = a2;
            this.nodes = [];
            this.links = [];
            this.series = [];
            this.box = { x: 0, y: 0, width: 0, height: 0 };
            this.setInitialRendering(true);
            this.integration = d2.integrations[a2.integration];
            this.enableSimulation = a2.enableSimulation;
            this.attractiveForce = p(a2.attractiveForce, this.integration.attractiveForceFunction);
            this.repulsiveForce = p(a2.repulsiveForce, this.integration.repulsiveForceFunction);
            this.approximation = a2.approximation;
          };
          c2.prototype.updateSimulation = function(a2) {
            this.enableSimulation = p(a2, this.options.enableSimulation);
          };
          c2.prototype.start = function() {
            var a2 = this.series, b2 = this.options;
            this.currentStep = 0;
            this.forces = a2[0] && a2[0].forces || [];
            this.chart = a2[0] && a2[0].chart;
            this.initialRendering && (this.initPositions(), a2.forEach(function(a3) {
              a3.finishedAnimating = true;
              a3.render();
            }));
            this.setK();
            this.resetSimulation(b2);
            this.enableSimulation && this.step();
          };
          c2.prototype.step = function() {
            var a2 = this, b2 = this.series;
            this.currentStep++;
            "barnes-hut" === this.approximation && (this.createQuadTree(), this.quadTree.calculateMassAndCenter());
            for (var c3 = 0, d3 = this.forces || []; c3 < d3.length; c3++)
              this[d3[c3] + "Forces"](this.temperature);
            this.applyLimits();
            this.temperature = this.coolDown(
              this.startTemperature,
              this.diffTemperature,
              this.currentStep
            );
            this.prevSystemTemperature = this.systemTemperature;
            this.systemTemperature = this.getSystemTemperature();
            if (this.enableSimulation) {
              for (c3 = 0; c3 < b2.length; c3++)
                d3 = b2[c3], d3.chart && d3.render();
              this.maxIterations-- && isFinite(this.temperature) && !this.isStable() ? (this.simulation && h.cancelAnimationFrame(this.simulation), this.simulation = h.requestAnimationFrame(function() {
                return a2.step();
              })) : this.simulation = false;
            }
          };
          c2.prototype.stop = function() {
            this.simulation && h.cancelAnimationFrame(this.simulation);
          };
          c2.prototype.setArea = function(a2, b2, c3, d3) {
            this.box = { left: a2, top: b2, width: c3, height: d3 };
          };
          c2.prototype.setK = function() {
            this.k = this.options.linkLength || this.integration.getK(this);
          };
          c2.prototype.addElementsToCollection = function(a2, b2) {
            for (var e = 0; e < a2.length; e++) {
              var c3 = a2[e];
              -1 === b2.indexOf(c3) && b2.push(c3);
            }
          };
          c2.prototype.removeElementFromCollection = function(a2, b2) {
            a2 = b2.indexOf(a2);
            -1 !== a2 && b2.splice(a2, 1);
          };
          c2.prototype.clear = function() {
            this.nodes.length = 0;
            this.links.length = 0;
            this.series.length = 0;
            this.resetSimulation();
          };
          c2.prototype.resetSimulation = function() {
            this.forcedStop = false;
            this.systemTemperature = 0;
            this.setMaxIterations();
            this.setTemperature();
            this.setDiffTemperature();
          };
          c2.prototype.restartSimulation = function() {
            this.simulation ? this.resetSimulation() : (this.setInitialRendering(false), this.enableSimulation ? this.start() : this.setMaxIterations(1), this.chart && this.chart.redraw(), this.setInitialRendering(true));
          };
          c2.prototype.setMaxIterations = function(a2) {
            this.maxIterations = p(a2, this.options.maxIterations);
          };
          c2.prototype.setTemperature = function() {
            this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
          };
          c2.prototype.setDiffTemperature = function() {
            this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
          };
          c2.prototype.setInitialRendering = function(a2) {
            this.initialRendering = a2;
          };
          c2.prototype.createQuadTree = function() {
            this.quadTree = new a(this.box.left, this.box.top, this.box.width, this.box.height);
            this.quadTree.insertNodes(this.nodes);
          };
          c2.prototype.initPositions = function() {
            var a2 = this.options.initialPositions;
            if (F(a2)) {
              a2.call(this);
              a2 = 0;
              for (var b2 = this.nodes; a2 < b2.length; a2++) {
                var c3 = b2[a2];
                q(c3.prevX) || (c3.prevX = c3.plotX);
                q(c3.prevY) || (c3.prevY = c3.plotY);
                c3.dispX = 0;
                c3.dispY = 0;
              }
            } else
              "circle" === a2 ? this.setCircularPositions() : this.setRandomPositions();
          };
          c2.prototype.setCircularPositions = function() {
            for (var a2 = this.box, b2 = this.nodes, c3 = 2 * Math.PI / (b2.length + 1), d3 = b2.filter(function(a3) {
              return 0 === a3.linksTo.length;
            }), f2 = {}, h2 = this.options.initialPositionRadius, l = function(a3) {
              var b3 = 0;
              for (a3 = a3.linksFrom || []; b3 < a3.length; b3++) {
                var c4 = a3[b3];
                f2[c4.toNode.id] || (f2[c4.toNode.id] = true, E.push(c4.toNode), l(c4.toNode));
              }
            }, E = [], v = 0; v < d3.length; v++) {
              var q2 = d3[v];
              E.push(q2);
              l(q2);
            }
            if (E.length)
              for (d3 = 0; d3 < b2.length; d3++)
                v = b2[d3], -1 === E.indexOf(v) && E.push(v);
            else
              E = b2;
            d3 = 0;
            for (v = E.length; d3 < v; ++d3)
              b2 = E[d3], b2.plotX = b2.prevX = p(b2.plotX, a2.width / 2 + h2 * Math.cos(d3 * c3)), b2.plotY = b2.prevY = p(b2.plotY, a2.height / 2 + h2 * Math.sin(d3 * c3)), b2.dispX = 0, b2.dispY = 0;
          };
          c2.prototype.setRandomPositions = function() {
            for (var a2 = this.box, b2 = this.nodes, c3 = b2.length + 1, d3 = function(a3) {
              a3 = a3 * a3 / Math.PI;
              return a3 -= Math.floor(a3);
            }, f2, h2 = 0, l = b2.length; h2 < l; ++h2)
              f2 = b2[h2], f2.plotX = f2.prevX = p(
                f2.plotX,
                a2.width * d3(h2)
              ), f2.plotY = f2.prevY = p(f2.plotY, a2.height * d3(c3 + h2)), f2.dispX = 0, f2.dispY = 0;
          };
          c2.prototype.force = function(a2) {
            for (var b2 = [], c3 = 1; c3 < arguments.length; c3++)
              b2[c3 - 1] = arguments[c3];
            this.integration[a2].apply(this, b2);
          };
          c2.prototype.barycenterForces = function() {
            this.getBarycenter();
            this.force("barycenter");
          };
          c2.prototype.getBarycenter = function() {
            for (var a2 = 0, b2 = 0, c3 = 0, d3 = 0, f2 = this.nodes; d3 < f2.length; d3++) {
              var h2 = f2[d3];
              b2 += h2.plotX * h2.mass;
              c3 += h2.plotY * h2.mass;
              a2 += h2.mass;
            }
            return this.barycenter = { x: b2, y: c3, xFactor: b2 / a2, yFactor: c3 / a2 };
          };
          c2.prototype.barnesHutApproximation = function(a2, b2) {
            var c3 = this.getDistXY(a2, b2), e = this.vectorLength(c3);
            if (a2 !== b2 && 0 !== e)
              if (b2.isInternal)
                if (b2.boxSize / e < this.options.theta && 0 !== e) {
                  var d3 = this.repulsiveForce(e, this.k);
                  this.force("repulsive", a2, d3 * b2.mass, c3, e);
                  var g = false;
                } else
                  g = true;
              else
                d3 = this.repulsiveForce(e, this.k), this.force("repulsive", a2, d3 * b2.mass, c3, e);
            return g;
          };
          c2.prototype.repulsiveForces = function() {
            var a2 = this;
            if ("barnes-hut" === this.approximation)
              for (var b2 = function(b3) {
                c3.quadTree.visitNodeRecursive(null, function(c4) {
                  return a2.barnesHutApproximation(
                    b3,
                    c4
                  );
                });
              }, c3 = this, d3 = 0, f2 = this.nodes; d3 < f2.length; d3++) {
                var h2 = f2[d3];
                b2(h2);
              }
            else {
              f2 = d3 = b2 = void 0;
              for (var l = 0, E = this.nodes; l < E.length; l++) {
                h2 = E[l];
                for (var v = 0, q2 = this.nodes; v < q2.length; v++) {
                  var n = q2[v];
                  h2 === n || h2.fixedPosition || (f2 = this.getDistXY(h2, n), d3 = this.vectorLength(f2), 0 !== d3 && (b2 = this.repulsiveForce(d3, this.k), this.force("repulsive", h2, b2 * n.mass, f2, d3)));
                }
              }
            }
          };
          c2.prototype.attractiveForces = function() {
            for (var a2, b2, c3, d3 = 0, f2 = this.links; d3 < f2.length; d3++) {
              var h2 = f2[d3];
              h2.fromNode && h2.toNode && (a2 = this.getDistXY(h2.fromNode, h2.toNode), b2 = this.vectorLength(a2), 0 !== b2 && (c3 = this.attractiveForce(b2, this.k), this.force("attractive", h2, c3, a2, b2)));
            }
          };
          c2.prototype.applyLimits = function() {
            for (var a2 = 0, b2 = this.nodes; a2 < b2.length; a2++) {
              var c3 = b2[a2];
              if (c3.fixedPosition)
                break;
              this.integration.integrate(this, c3);
              this.applyLimitBox(c3, this.box);
              c3.dispX = 0;
              c3.dispY = 0;
            }
          };
          c2.prototype.applyLimitBox = function(a2, b2) {
            var c3 = a2.radius;
            a2.plotX = r(a2.plotX, b2.left + c3, b2.width - c3);
            a2.plotY = r(a2.plotY, b2.top + c3, b2.height - c3);
          };
          c2.prototype.coolDown = function(a2, b2, c3) {
            return a2 - b2 * c3;
          };
          c2.prototype.isStable = function() {
            return 1e-5 > Math.abs(this.systemTemperature - this.prevSystemTemperature) || 0 >= this.temperature;
          };
          c2.prototype.getSystemTemperature = function() {
            for (var a2 = 0, b2 = 0, c3 = this.nodes; b2 < c3.length; b2++)
              a2 += c3[b2].temperature;
            return a2;
          };
          c2.prototype.vectorLength = function(a2) {
            return Math.sqrt(a2.x * a2.x + a2.y * a2.y);
          };
          c2.prototype.getDistR = function(a2, b2) {
            a2 = this.getDistXY(a2, b2);
            return this.vectorLength(a2);
          };
          c2.prototype.getDistXY = function(a2, b2) {
            var c3 = a2.plotX - b2.plotX;
            a2 = a2.plotY - b2.plotY;
            return { x: c3, y: a2, absX: Math.abs(c3), absY: Math.abs(a2) };
          };
          return c2;
        }();
      });
      D(
        d,
        "Series/PackedBubble/PackedBubbleLayout.js",
        [d["Series/GraphLayoutComposition.js"], d["Series/PackedBubble/PackedBubbleIntegration.js"], d["Series/Networkgraph/ReingoldFruchtermanLayout.js"], d["Core/Utilities.js"]],
        function(b, c, d2, a) {
          function f() {
            var a2 = [];
            this.series.forEach(function(b2) {
              b2.parentNode && b2.parentNode.selected && a2.push(b2.parentNode);
            });
            return a2;
          }
          function h() {
            this.allDataPoints && delete this.allDataPoints;
          }
          var n = this && this.__extends || function() {
            var a2 = function(b2, c2) {
              a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
                a3.__proto__ = b3;
              } || function(a3, b3) {
                for (var c3 in b3)
                  b3.hasOwnProperty(c3) && (a3[c3] = b3[c3]);
              };
              return a2(b2, c2);
            };
            return function(b2, c2) {
              function e() {
                this.constructor = b2;
              }
              a2(b2, c2);
              b2.prototype = null === c2 ? Object.create(c2) : (e.prototype = c2.prototype, new e());
            };
          }(), r = a.addEvent, q = a.pick, F = [];
          a = function(a2) {
            function l() {
              var b2 = null !== a2 && a2.apply(this, arguments) || this;
              b2.index = NaN;
              b2.nodes = [];
              b2.options = void 0;
              b2.series = [];
              return b2;
            }
            n(l, a2);
            l.compose = function(a3) {
              d2.compose(a3);
              b.integrations.packedbubble = c;
              b.layouts.packedbubble = l;
              -1 === F.indexOf(a3) && (F.push(a3), r(a3, "beforeRedraw", h), a3.prototype.getSelectedParentNodes = f);
            };
            l.prototype.beforeStep = function() {
              this.options.marker && this.series.forEach(function(a3) {
                a3 && a3.calculateParentRadius();
              });
            };
            l.prototype.isStable = function() {
              var a3 = Math.abs(this.prevSystemTemperature - this.systemTemperature);
              return 1 > Math.abs(10 * this.systemTemperature / Math.sqrt(this.nodes.length)) && 1e-5 > a3 || 0 >= this.temperature;
            };
            l.prototype.setCircularPositions = function() {
              for (var a3 = this.box, b2 = this.nodes, c2 = 2 * Math.PI / (b2.length + 1), d3 = this.options.initialPositionRadius, f2, h2, l2 = 0, E = 0; E < b2.length; E++) {
                var v = b2[E];
                this.options.splitSeries && !v.isParentNode ? (f2 = v.series.parentNode.plotX, h2 = v.series.parentNode.plotY) : (f2 = a3.width / 2, h2 = a3.height / 2);
                v.plotX = v.prevX = q(v.plotX, f2 + d3 * Math.cos(v.index || l2 * c2));
                v.plotY = v.prevY = q(v.plotY, h2 + d3 * Math.sin(v.index || l2 * c2));
                v.dispX = 0;
                v.dispY = 0;
                l2++;
              }
            };
            l.prototype.repulsiveForces = function() {
              var a3 = this, b2 = a3.options.bubblePadding, c2, d3, f2;
              a3.nodes.forEach(function(e) {
                e.degree = e.mass;
                e.neighbours = 0;
                a3.nodes.forEach(function(g) {
                  c2 = 0;
                  e === g || e.fixedPosition || !a3.options.seriesInteraction && e.series !== g.series || (f2 = a3.getDistXY(e, g), d3 = a3.vectorLength(f2) - (e.marker.radius + g.marker.radius + b2), 0 > d3 && (e.degree += 0.01, e.neighbours++, c2 = a3.repulsiveForce(-d3 / Math.sqrt(e.neighbours), a3.k, e, g)), a3.force("repulsive", e, c2 * g.mass, f2, g, d3));
                });
              });
            };
            l.prototype.applyLimitBox = function(b2, c2) {
              if (this.options.splitSeries && !b2.isParentNode && this.options.parentNodeLimit) {
                var e = this.getDistXY(b2, b2.series.parentNode);
                var d3 = b2.series.parentNodeRadius - b2.marker.radius - this.vectorLength(e);
                0 > d3 && d3 > -2 * b2.marker.radius && (b2.plotX -= 0.01 * e.x, b2.plotY -= 0.01 * e.y);
              }
              a2.prototype.applyLimitBox.call(this, b2, c2);
            };
            return l;
          }(d2);
          return b.layouts.packedbubble = a;
        }
      );
      D(d, "Series/PackedBubble/PackedBubbleSeries.js", [
        d["Core/Color/Color.js"],
        d["Series/DragNodesComposition.js"],
        d["Series/GraphLayoutComposition.js"],
        d["Core/Globals.js"],
        d["Series/PackedBubble/PackedBubblePoint.js"],
        d["Series/PackedBubble/PackedBubbleSeriesDefaults.js"],
        d["Series/PackedBubble/PackedBubbleLayout.js"],
        d["Core/Series/SeriesRegistry.js"],
        d["Core/Utilities.js"]
      ], function(b, c, d2, a, f, w, n, r, q) {
        var h = this && this.__extends || function() {
          var a2 = function(b2, c2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
              a3.__proto__ = b3;
            } || function(a3, b3) {
              for (var c3 in b3)
                b3.hasOwnProperty(c3) && (a3[c3] = b3[c3]);
            };
            return a2(b2, c2);
          };
          return function(b2, c2) {
            function e2() {
              this.constructor = b2;
            }
            a2(b2, c2);
            b2.prototype = null === c2 ? Object.create(c2) : (e2.prototype = c2.prototype, new e2());
          };
        }(), p = b.parse;
        b = a.noop;
        var l = r.series.prototype, e = r.seriesTypes.bubble, g = q.addEvent, k = q.clamp, m = q.defined, D2 = q.extend, G = q.fireEvent, L = q.isArray, E = q.isNumber, v = q.merge, Q = q.pick;
        q = function(a2) {
          function b2() {
            var b3 = null !== a2 && a2.apply(this, arguments) || this;
            b3.chart = void 0;
            b3.data = void 0;
            b3.layout = void 0;
            b3.options = void 0;
            b3.parentNodeMass = 0;
            b3.points = void 0;
            b3.xData = void 0;
            return b3;
          }
          h(b2, a2);
          b2.compose = function(a3, b3, d3, f2) {
            e.compose(a3, b3, d3, f2);
            c.compose(b3);
            n.compose(b3);
          };
          b2.prototype.accumulateAllPoints = function() {
            for (var a3 = this.chart, b3 = [], c2, e2 = 0, d3 = a3.series; e2 < d3.length; e2++) {
              var f2 = d3[e2];
              if (f2.is("packedbubble") && f2.visible || !a3.options.chart.ignoreHiddenSeries) {
                c2 = f2.yData || [];
                for (var g2 = 0; g2 < c2.length; g2++)
                  b3.push([null, null, c2[g2], f2.index, g2, { id: g2, marker: { radius: 0 } }]);
              }
            }
            return b3;
          };
          b2.prototype.addLayout = function() {
            var a3 = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {}, b3 = a3.type || "packedbubble", c2 = this.chart.options.chart, e2 = this.chart.graphLayoutsStorage, f2 = this.chart.graphLayoutsLookup;
            e2 || (this.chart.graphLayoutsStorage = e2 = {}, this.chart.graphLayoutsLookup = f2 = []);
            var g2 = e2[b3];
            g2 || (a3.enableSimulation = m(c2.forExport) ? !c2.forExport : a3.enableSimulation, e2[b3] = g2 = new d2.layouts[b3](), g2.init(a3), f2.splice(g2.index, 0, g2));
            this.layout = g2;
            this.points.forEach(function(a4) {
              a4.mass = 2;
              a4.degree = 1;
              a4.collisionNmb = 1;
            });
            g2.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);
            g2.addElementsToCollection([this], g2.series);
            g2.addElementsToCollection(this.points, g2.nodes);
          };
          b2.prototype.addSeriesLayout = function() {
            var a3 = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {}, b3 = a3.type || "packedbubble", c2 = this.chart.graphLayoutsStorage, e2 = this.chart.graphLayoutsLookup;
            a3 = v(a3, a3.parentNodeOptions, { enableSimulation: this.layout.options.enableSimulation });
            var f2 = c2[b3 + "-series"];
            f2 || (c2[b3 + "-series"] = f2 = new d2.layouts[b3](), f2.init(a3), e2.splice(f2.index, 0, f2));
            this.parentNodeLayout = f2;
            this.createParentNodes();
          };
          b2.prototype.calculateParentRadius = function() {
            var a3 = this.seriesBox();
            this.parentNodeRadius = k(Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20, 20, a3 ? Math.max(Math.sqrt(Math.pow(a3.width, 2) + Math.pow(a3.height, 2)) / 2 + 20, 20) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + 20);
            this.parentNode && (this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius);
          };
          b2.prototype.calculateZExtremes = function() {
            var a3 = this.options.zMin, b3 = this.options.zMax, c2 = Infinity, e2 = -Infinity;
            if (a3 && b3)
              return [a3, b3];
            this.chart.series.forEach(function(a4) {
              a4.yData.forEach(function(a5) {
                m(a5) && (a5 > e2 && (e2 = a5), a5 < c2 && (c2 = a5));
              });
            });
            a3 = Q(a3, c2);
            b3 = Q(b3, e2);
            return [a3, b3];
          };
          b2.prototype.checkOverlap = function(a3, b3) {
            var c2 = a3[0] - b3[0], e2 = a3[1] - b3[1];
            return -1e-3 > Math.sqrt(c2 * c2 + e2 * e2) - Math.abs(a3[2] + b3[2]);
          };
          b2.prototype.createParentNodes = function() {
            var a3 = this, b3 = this.pointClass, c2 = this.chart, e2 = this.parentNodeLayout, d3 = this.layout.options, f2, g2 = this.parentNode, h2 = { radius: this.parentNodeRadius, lineColor: this.color, fillColor: p(this.color).brighten(0.4).get() };
            d3.parentNodeOptions && (h2 = v(d3.parentNodeOptions.marker || {}, h2));
            this.parentNodeMass = 0;
            this.points.forEach(function(b4) {
              a3.parentNodeMass += Math.PI * Math.pow(b4.marker.radius, 2);
            });
            this.calculateParentRadius();
            e2.nodes.forEach(function(b4) {
              b4.seriesIndex === a3.index && (f2 = true);
            });
            e2.setArea(0, 0, c2.plotWidth, c2.plotHeight);
            f2 || (g2 || (g2 = new b3().init(this, { mass: this.parentNodeRadius / 2, marker: h2, dataLabels: { inside: false }, states: { normal: { marker: h2 }, hover: { marker: h2 } }, dataLabelOnNull: true, degree: this.parentNodeRadius, isParentNode: true, seriesIndex: this.index })), this.parentNode && (g2.plotX = this.parentNode.plotX, g2.plotY = this.parentNode.plotY), this.parentNode = g2, e2.addElementsToCollection([this], e2.series), e2.addElementsToCollection([g2], e2.nodes));
          };
          b2.prototype.deferLayout = function() {
            var a3 = this.options.layoutAlgorithm;
            this.visible && (this.addLayout(), a3.splitSeries && this.addSeriesLayout());
          };
          b2.prototype.destroy = function() {
            var a3 = this;
            this.chart.graphLayoutsLookup && this.chart.graphLayoutsLookup.forEach(function(b3) {
              b3.removeElementFromCollection(a3, b3.series);
            }, this);
            this.parentNode && this.parentNodeLayout && (this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes), this.parentNode.dataLabel && (this.parentNode.dataLabel = this.parentNode.dataLabel.destroy()));
            l.destroy.apply(this, arguments);
          };
          b2.prototype.drawDataLabels = function() {
            l.drawDataLabels.call(this, this.points);
            this.parentNode && (this.parentNode.formatPrefix = "parentNode", l.drawDataLabels.call(this, [this.parentNode]));
          };
          b2.prototype.drawGraph = function() {
            if (this.layout && this.layout.options.splitSeries) {
              var a3 = this.chart, b3 = this.layout.options.parentNodeOptions.marker;
              b3 = { fill: b3.fillColor || p(this.color).brighten(0.4).get(), opacity: b3.fillOpacity, stroke: b3.lineColor || this.color, "stroke-width": Q(b3.lineWidth, this.options.lineWidth) };
              this.parentNodesGroup || (this.parentNodesGroup = this.plotGroup("parentNodesGroup", "parentNode", this.visible ? "inherit" : "hidden", 0.1, a3.seriesGroup), this.group.attr({ zIndex: 2 }));
              this.calculateParentRadius();
              var c2 = v({ x: this.parentNode.plotX - this.parentNodeRadius, y: this.parentNode.plotY - this.parentNodeRadius, width: 2 * this.parentNodeRadius, height: 2 * this.parentNodeRadius }, b3);
              this.parentNode.graphic || (this.graph = this.parentNode.graphic = a3.renderer.symbol(b3.symbol).add(this.parentNodesGroup));
              this.parentNode.graphic.attr(c2);
            }
          };
          b2.prototype.drawTracker = function() {
            var b3 = this.parentNode;
            a2.prototype.drawTracker.call(this);
            if (b3) {
              var c2 = L(b3.dataLabels) ? b3.dataLabels : b3.dataLabel ? [b3.dataLabel] : [];
              b3.graphic && (b3.graphic.element.point = b3);
              c2.forEach(function(a3) {
                a3.div ? a3.div.point = b3 : a3.element.point = b3;
              });
            }
          };
          b2.prototype.getPointRadius = function() {
            var a3 = this, b3 = this.chart, c2 = this.options, e2 = c2.useSimulation, d3 = Math.min(b3.plotWidth, b3.plotHeight), f2 = {}, g2 = [], h2 = b3.allDataPoints || [], m2 = h2.length, l2, v2, u, C;
            ["minSize", "maxSize"].forEach(function(a4) {
              var b4 = parseInt(c2[a4], 10), e3 = /%$/.test(c2[a4]);
              f2[a4] = e3 ? d3 * b4 / 100 : b4 * Math.sqrt(m2);
            });
            b3.minRadius = l2 = f2.minSize / Math.sqrt(m2);
            b3.maxRadius = v2 = f2.maxSize / Math.sqrt(m2);
            var z = e2 ? this.calculateZExtremes() : [l2, v2];
            h2.forEach(function(b4, c3) {
              u = e2 ? k(b4[2], z[0], z[1]) : b4[2];
              C = a3.getRadius(z[0], z[1], l2, v2, u);
              0 === C && (C = null);
              h2[c3][2] = C;
              g2.push(C);
            });
            this.radii = g2;
          };
          b2.prototype.init = function() {
            l.init.apply(this, arguments);
            this.eventsToUnbind.push(g(this, "updatedData", function() {
              var a3 = this;
              this.chart.series.forEach(function(b3) {
                b3.type === a3.type && (b3.isDirty = true);
              }, this);
            }));
            return this;
          };
          b2.prototype.onMouseUp = function(a3) {
            var b3 = a3;
            if (b3.fixedPosition && !b3.removed) {
              var e2 = this.layout, d3 = this.parentNodeLayout, f2, g2;
              d3 && e2.options.dragBetweenSeries && d3.nodes.forEach(function(a4) {
                b3 && b3.marker && a4 !== b3.series.parentNode && (f2 = e2.getDistXY(b3, a4), g2 = e2.vectorLength(f2) - a4.marker.radius - b3.marker.radius, 0 > g2 && (a4.series.addPoint(v(b3.options, { plotX: b3.plotX, plotY: b3.plotY }), false), e2.removeElementFromCollection(b3, e2.nodes), b3.remove()));
              });
              c.onMouseUp.apply(this, arguments);
            }
          };
          b2.prototype.placeBubbles = function(a3) {
            var b3 = this.checkOverlap, c2 = this.positionBubble, e2 = [], d3 = 1, f2 = 0, g2 = 0;
            var h2 = [];
            var k2;
            a3 = a3.sort(function(a4, b4) {
              return b4[2] - a4[2];
            });
            if (a3.length) {
              e2.push([[0, 0, a3[0][2], a3[0][3], a3[0][4]]]);
              if (1 < a3.length)
                for (e2.push([[0, 0 - a3[1][2] - a3[0][2], a3[1][2], a3[1][3], a3[1][4]]]), k2 = 2; k2 < a3.length; k2++)
                  a3[k2][2] = a3[k2][2] || 1, h2 = c2(e2[d3][f2], e2[d3 - 1][g2], a3[k2]), b3(h2, e2[d3][0]) ? (e2.push([]), g2 = 0, e2[d3 + 1].push(c2(e2[d3][f2], e2[d3][0], a3[k2])), d3++, f2 = 0) : 1 < d3 && e2[d3 - 1][g2 + 1] && b3(h2, e2[d3 - 1][g2 + 1]) ? (g2++, e2[d3].push(c2(e2[d3][f2], e2[d3 - 1][g2], a3[k2])), f2++) : (f2++, e2[d3].push(h2));
              this.chart.stages = e2;
              this.chart.rawPositions = [].concat.apply([], e2);
              this.resizeRadius();
              h2 = this.chart.rawPositions;
            }
            return h2;
          };
          b2.prototype.pointAttribs = function(a3, b3) {
            var c2 = this.options, e2 = c2.marker;
            a3 && a3.isParentNode && c2.layoutAlgorithm && c2.layoutAlgorithm.parentNodeOptions && (e2 = c2.layoutAlgorithm.parentNodeOptions.marker);
            c2 = e2.fillOpacity;
            a3 = l.pointAttribs.call(this, a3, b3);
            1 !== c2 && (a3["fill-opacity"] = c2);
            return a3;
          };
          b2.prototype.positionBubble = function(a3, b3, c2) {
            var e2 = Math.sqrt, d3 = Math.asin, f2 = Math.acos, g2 = Math.pow, h2 = Math.abs;
            e2 = e2(g2(a3[0] - b3[0], 2) + g2(a3[1] - b3[1], 2));
            f2 = f2((g2(e2, 2) + g2(c2[2] + b3[2], 2) - g2(c2[2] + a3[2], 2)) / (2 * (c2[2] + b3[2]) * e2));
            d3 = d3(h2(a3[0] - b3[0]) / e2);
            a3 = (0 > a3[1] - b3[1] ? 0 : Math.PI) + f2 + d3 * (0 > (a3[0] - b3[0]) * (a3[1] - b3[1]) ? 1 : -1);
            return [b3[0] + (b3[2] + c2[2]) * Math.sin(a3), b3[1] - (b3[2] + c2[2]) * Math.cos(a3), c2[2], c2[3], c2[4]];
          };
          b2.prototype.render = function() {
            var a3 = [];
            l.render.apply(this, arguments);
            this.options.dataLabels.allowOverlap || (this.data.forEach(function(b3) {
              L(b3.dataLabels) && b3.dataLabels.forEach(function(b4) {
                a3.push(b4);
              });
            }), this.options.useSimulation && this.chart.hideOverlappingLabels(a3));
          };
          b2.prototype.resizeRadius = function() {
            var a3 = this.chart, b3 = a3.rawPositions, c2 = Math.min, e2 = Math.max, d3 = a3.plotLeft, f2 = a3.plotTop, g2 = a3.plotHeight, h2 = a3.plotWidth, k2, m2;
            var l2 = k2 = Number.POSITIVE_INFINITY;
            var u = m2 = Number.NEGATIVE_INFINITY;
            for (var C = 0; C < b3.length; C++) {
              var z = b3[C];
              var v2 = z[2];
              l2 = c2(l2, z[0] - v2);
              u = e2(u, z[0] + v2);
              k2 = c2(k2, z[1] - v2);
              m2 = e2(m2, z[1] + v2);
            }
            z = [u - l2, m2 - k2];
            c2 = c2.apply([], [(h2 - d3) / z[0], (g2 - f2) / z[1]]);
            if (1e-10 < Math.abs(c2 - 1)) {
              for (a3 = 0; a3 < b3.length; a3++)
                z = b3[a3], z[2] *= c2;
              this.placeBubbles(b3);
            } else
              a3.diffY = g2 / 2 + f2 - k2 - (m2 - k2) / 2, a3.diffX = h2 / 2 + d3 - l2 - (u - l2) / 2;
          };
          b2.prototype.seriesBox = function() {
            var a3 = this.chart, b3 = Math.max, c2 = Math.min, e2 = [
              a3.plotLeft,
              a3.plotLeft + a3.plotWidth,
              a3.plotTop,
              a3.plotTop + a3.plotHeight
            ], d3;
            this.data.forEach(function(a4) {
              m(a4.plotX) && m(a4.plotY) && a4.marker.radius && (d3 = a4.marker.radius, e2[0] = c2(e2[0], a4.plotX - d3), e2[1] = b3(e2[1], a4.plotX + d3), e2[2] = c2(e2[2], a4.plotY - d3), e2[3] = b3(e2[3], a4.plotY + d3));
            });
            return E(e2.width / e2.height) ? e2 : null;
          };
          b2.prototype.setVisible = function() {
            var a3 = this;
            l.setVisible.apply(a3, arguments);
            a3.parentNodeLayout && a3.graph ? a3.visible ? (a3.graph.show(), a3.parentNode.dataLabel && a3.parentNode.dataLabel.show()) : (a3.graph.hide(), a3.parentNodeLayout.removeElementFromCollection(
              a3.parentNode,
              a3.parentNodeLayout.nodes
            ), a3.parentNode.dataLabel && a3.parentNode.dataLabel.hide()) : a3.layout && (a3.visible ? a3.layout.addElementsToCollection(a3.points, a3.layout.nodes) : a3.points.forEach(function(b3) {
              a3.layout.removeElementFromCollection(b3, a3.layout.nodes);
            }));
          };
          b2.prototype.translate = function() {
            var a3 = this.chart, b3 = this.data, c2 = this.index, e2 = this.options.useSimulation;
            this.processedXData = this.xData;
            this.generatePoints();
            m(a3.allDataPoints) || (a3.allDataPoints = this.accumulateAllPoints(), this.getPointRadius());
            if (e2)
              var d3 = a3.allDataPoints;
            else
              d3 = this.placeBubbles(a3.allDataPoints), this.options.draggable = false;
            for (var f2 = 0, g2 = d3; f2 < g2.length; f2++) {
              var h2 = g2[f2];
              if (h2[3] === c2) {
                d3 = b3[h2[4]];
                var k2 = Q(h2[2], void 0);
                e2 || (d3.plotX = h2[0] - a3.plotLeft + a3.diffX, d3.plotY = h2[1] - a3.plotTop + a3.diffY);
                E(k2) && (d3.marker = D2(d3.marker, { radius: k2, width: 2 * k2, height: 2 * k2 }), d3.radius = k2);
              }
            }
            e2 && this.deferLayout();
            G(this, "afterTranslate");
          };
          b2.defaultOptions = v(e.defaultOptions, w);
          return b2;
        }(e);
        D2(q.prototype, {
          pointClass: f,
          axisTypes: [],
          directTouch: true,
          forces: ["barycenter", "repulsive"],
          hasDraggableNodes: true,
          isCartesian: false,
          noSharedTooltip: true,
          pointArrayMap: ["value"],
          pointValKey: "value",
          requireSorting: false,
          trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"],
          alignDataLabel: l.alignDataLabel,
          indexateNodes: b,
          onMouseDown: c.onMouseDown,
          onMouseMove: c.onMouseMove,
          redrawHalo: c.redrawHalo,
          searchPoint: b
        });
        r.registerSeriesType("packedbubble", q);
        "";
        return q;
      });
      D(
        d,
        "Series/Polygon/PolygonSeries.js",
        [d["Core/Globals.js"], d["Core/Legend/LegendSymbol.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"]],
        function(b, c, d2, a) {
          var f = this && this.__extends || function() {
            var a2 = function(b2, c2) {
              a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
                a3.__proto__ = b3;
              } || function(a3, b3) {
                for (var c3 in b3)
                  b3.hasOwnProperty(c3) && (a3[c3] = b3[c3]);
              };
              return a2(b2, c2);
            };
            return function(b2, c2) {
              function e() {
                this.constructor = b2;
              }
              a2(b2, c2);
              b2.prototype = null === c2 ? Object.create(c2) : (e.prototype = c2.prototype, new e());
            };
          }();
          b = b.noop;
          var h = d2.series, n = d2.seriesTypes, r = n.area, q = n.line, F = n.scatter;
          n = a.extend;
          var p = a.merge;
          a = function(a2) {
            function b2() {
              var b3 = null !== a2 && a2.apply(this, arguments) || this;
              b3.data = void 0;
              b3.options = void 0;
              b3.points = void 0;
              return b3;
            }
            f(b2, a2);
            b2.prototype.getGraphPath = function() {
              for (var a3 = q.prototype.getGraphPath.call(this), b3 = a3.length + 1; b3--; )
                (b3 === a3.length || "M" === a3[b3][0]) && 0 < b3 && a3.splice(b3, 0, ["Z"]);
              return this.areaPath = a3;
            };
            b2.prototype.drawGraph = function() {
              this.options.fillColor = this.color;
              r.prototype.drawGraph.call(this);
            };
            b2.defaultOptions = p(F.defaultOptions, { marker: { enabled: false, states: { hover: { enabled: false } } }, stickyTracking: false, tooltip: {
              followPointer: true,
              pointFormat: ""
            }, trackByArea: true });
            return b2;
          }(F);
          n(a.prototype, { type: "polygon", drawLegendSymbol: c.drawRectangle, drawTracker: h.prototype.drawTracker, setStackedPoints: b });
          d2.registerSeriesType("polygon", a);
          "";
          return a;
        }
      );
      D(d, "Core/Axis/WaterfallAxis.js", [d["Core/Axis/Stacking/StackItem.js"], d["Core/Utilities.js"]], function(b, c) {
        var d2 = c.addEvent, a = c.objectEach, f;
        (function(c2) {
          function f2() {
            var a2 = this.waterfall.stacks;
            a2 && (a2.changed = false, delete a2.alreadyChanged);
          }
          function h() {
            var a2 = this.options.stackLabels;
            a2 && a2.enabled && this.waterfall.stacks && this.waterfall.renderStackTotals();
          }
          function q() {
            for (var a2 = this.axes, b2 = this.series, c3 = b2.length; c3--; )
              b2[c3].options.stacking && (a2.forEach(function(a3) {
                a3.isXAxis || (a3.waterfall.stacks.changed = true);
              }), c3 = 0);
          }
          function w() {
            this.waterfall || (this.waterfall = new p(this));
          }
          var p = function() {
            function c3(a2) {
              this.axis = a2;
              this.stacks = { changed: false };
            }
            c3.prototype.renderStackTotals = function() {
              var c4 = this.axis, d3 = c4.waterfall.stacks, f3 = c4.stacking && c4.stacking.stackTotalGroup, h2 = new b(
                c4,
                c4.options.stackLabels || {},
                false,
                0,
                void 0
              );
              this.dummyStackItem = h2;
              f3 && a(d3, function(c5) {
                a(c5, function(a2, c6) {
                  h2.total = a2.stackTotal;
                  h2.x = +c6;
                  a2.label && (h2.label = a2.label);
                  b.prototype.render.call(h2, f3);
                  a2.label = h2.label;
                  delete h2.label;
                });
              });
              h2.total = null;
            };
            return c3;
          }();
          c2.Composition = p;
          c2.compose = function(a2, b2) {
            d2(a2, "init", w);
            d2(a2, "afterBuildStacks", f2);
            d2(a2, "afterRender", h);
            d2(b2, "beforeRedraw", q);
          };
        })(f || (f = {}));
        return f;
      });
      D(d, "Series/Waterfall/WaterfallPoint.js", [d["Series/Column/ColumnSeries.js"], d["Core/Series/Point.js"], d["Core/Utilities.js"]], function(b, c, d2) {
        var a = this && this.__extends || function() {
          var a2 = function(b2, c2) {
            a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
              a3.__proto__ = b3;
            } || function(a3, b3) {
              for (var c3 in b3)
                b3.hasOwnProperty(c3) && (a3[c3] = b3[c3]);
            };
            return a2(b2, c2);
          };
          return function(b2, c2) {
            function d3() {
              this.constructor = b2;
            }
            a2(b2, c2);
            b2.prototype = null === c2 ? Object.create(c2) : (d3.prototype = c2.prototype, new d3());
          };
        }(), f = d2.isNumber;
        return function(b2) {
          function d3() {
            var a2 = null !== b2 && b2.apply(this, arguments) || this;
            a2.options = void 0;
            a2.series = void 0;
            return a2;
          }
          a(d3, b2);
          d3.prototype.getClassName = function() {
            var a2 = c.prototype.getClassName.call(this);
            this.isSum ? a2 += " highcharts-sum" : this.isIntermediateSum && (a2 += " highcharts-intermediate-sum");
            return a2;
          };
          d3.prototype.isValid = function() {
            return f(this.y) || this.isSum || !!this.isIntermediateSum;
          };
          return d3;
        }(b.prototype.pointClass);
      });
      D(
        d,
        "Series/Waterfall/WaterfallSeries.js",
        [d["Core/Axis/Axis.js"], d["Core/Chart/Chart.js"], d["Core/Series/SeriesRegistry.js"], d["Core/Utilities.js"], d["Core/Axis/WaterfallAxis.js"], d["Series/Waterfall/WaterfallPoint.js"]],
        function(b, c, d2, a, f, w) {
          var h = this && this.__extends || function() {
            var a2 = function(b2, c2) {
              a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, b3) {
                a3.__proto__ = b3;
              } || function(a3, b3) {
                for (var c3 in b3)
                  b3.hasOwnProperty(c3) && (a3[c3] = b3[c3]);
              };
              return a2(b2, c2);
            };
            return function(b2, c2) {
              function e2() {
                this.constructor = b2;
              }
              a2(b2, c2);
              b2.prototype = null === c2 ? Object.create(c2) : (e2.prototype = c2.prototype, new e2());
            };
          }(), r = d2.seriesTypes, q = r.column, F = r.line, p = a.arrayMax, l = a.arrayMin, e = a.correctFloat;
          r = a.extend;
          var g = a.isNumber, k = a.merge, m = a.objectEach, D2 = a.pick;
          a = function(a2) {
            function b2() {
              var b3 = null !== a2 && a2.apply(this, arguments) || this;
              b3.chart = void 0;
              b3.data = void 0;
              b3.options = void 0;
              b3.points = void 0;
              b3.stackedYNeg = void 0;
              b3.stackedYPos = void 0;
              b3.stackKey = void 0;
              b3.xData = void 0;
              b3.yAxis = void 0;
              b3.yData = void 0;
              return b3;
            }
            h(b2, a2);
            b2.prototype.generatePoints = function() {
              q.prototype.generatePoints.apply(this);
              for (var a3 = 0, b3 = this.points.length; a3 < b3; a3++) {
                var c2 = this.points[a3], d3 = this.processedYData[a3];
                g(d3) && (c2.isIntermediateSum || c2.isSum) && (c2.y = e(d3));
              }
            };
            b2.prototype.translate = function() {
              var a3 = this.options, b3 = this.yAxis, c2 = D2(a3.minPointLength, 5), e2 = c2 / 2, d3 = a3.threshold || 0;
              a3 = a3.stacking;
              var f2 = b3.waterfall.stacks[this.stackKey], h2 = d3, k2 = d3;
              q.prototype.translate.apply(this);
              for (var m2 = this.points, t = 0; t < m2.length; t++) {
                var l2 = m2[t];
                var n = this.processedYData[t];
                var p2 = l2.shapeArgs;
                if (p2 && g(n)) {
                  var A = [0, n];
                  var r2 = l2.y;
                  if (a3) {
                    if (f2) {
                      A = f2[t];
                      if ("overlap" === a3) {
                        var w2 = A.stackState[A.stateIndex--];
                        w2 = 0 <= r2 ? w2 : w2 - r2;
                        Object.hasOwnProperty.call(A, "absolutePos") && delete A.absolutePos;
                        Object.hasOwnProperty.call(A, "absoluteNeg") && delete A.absoluteNeg;
                      } else
                        0 <= r2 ? (w2 = A.threshold + A.posTotal, A.posTotal -= r2) : (w2 = A.threshold + A.negTotal, A.negTotal -= r2, w2 -= r2), !A.posTotal && g(A.absolutePos) && Object.hasOwnProperty.call(A, "absolutePos") && (A.posTotal = A.absolutePos, delete A.absolutePos), !A.negTotal && g(A.absoluteNeg) && Object.hasOwnProperty.call(A, "absoluteNeg") && (A.negTotal = A.absoluteNeg, delete A.absoluteNeg);
                      l2.isSum || (A.connectorThreshold = A.threshold + A.stackTotal);
                      b3.reversed ? (n = 0 <= r2 ? w2 - r2 : w2 + r2, r2 = w2) : (n = w2, r2 = w2 - r2);
                      l2.below = n <= d3;
                      p2.y = b3.translate(
                        n,
                        false,
                        true,
                        false,
                        true
                      );
                      p2.height = Math.abs(p2.y - b3.translate(r2, false, true, false, true));
                      if (r2 = b3.waterfall.dummyStackItem)
                        r2.x = t, r2.label = f2[t].label, r2.setOffset(this.pointXOffset || 0, this.barW || 0, this.stackedYNeg[t], this.stackedYPos[t], void 0, this.xAxis);
                    }
                  } else
                    w2 = Math.max(k2, k2 + r2) + A[0], p2.y = b3.translate(w2, false, true, false, true), l2.isSum ? (p2.y = b3.translate(A[1], false, true, false, true), p2.height = Math.min(b3.translate(A[0], false, true, false, true), b3.len) - p2.y, l2.below = A[1] <= d3) : l2.isIntermediateSum ? (0 <= r2 ? (n = A[1] + h2, r2 = h2) : (n = h2, r2 = A[1] + h2), b3.reversed && (n ^= r2, r2 ^= n, n ^= r2), p2.y = b3.translate(
                      n,
                      false,
                      true,
                      false,
                      true
                    ), p2.height = Math.abs(p2.y - Math.min(b3.translate(r2, false, true, false, true), b3.len)), h2 += A[1], l2.below = n <= d3) : (p2.height = 0 < n ? b3.translate(k2, false, true, false, true) - p2.y : b3.translate(k2, false, true, false, true) - b3.translate(k2 - n, false, true, false, true), k2 += n, l2.below = k2 < d3), 0 > p2.height && (p2.y += p2.height, p2.height *= -1);
                  l2.plotY = p2.y = Math.round(p2.y || 0) - this.borderWidth % 2 / 2;
                  p2.height = Math.max(Math.round(p2.height || 0), 1e-3);
                  l2.yBottom = p2.y + p2.height;
                  p2.height <= c2 && !l2.isNull ? (p2.height = c2, p2.y -= e2, l2.plotY = p2.y, l2.minPointLengthOffset = 0 > l2.y ? -e2 : e2) : (l2.isNull && (p2.width = 0), l2.minPointLengthOffset = 0);
                  r2 = l2.plotY + (l2.negative ? p2.height : 0);
                  l2.below && (l2.plotY += p2.height);
                  l2.tooltipPos && (this.chart.inverted ? l2.tooltipPos[0] = b3.len - r2 : l2.tooltipPos[1] = r2);
                  l2.isInside = this.isPointInside(l2);
                }
              }
            };
            b2.prototype.processData = function(b3) {
              var c2 = this.options, d3 = this.yData, f2 = c2.data, g2 = d3.length, h2 = c2.threshold || 0, k2, l2, m2, t, n;
              for (n = l2 = k2 = m2 = t = 0; n < g2; n++) {
                var q2 = d3[n];
                var p2 = f2 && f2[n] ? f2[n] : {};
                "sum" === q2 || p2.isSum ? d3[n] = e(l2) : "intermediateSum" === q2 || p2.isIntermediateSum ? (d3[n] = e(k2), k2 = 0) : (l2 += q2, k2 += q2);
                m2 = Math.min(l2, m2);
                t = Math.max(l2, t);
              }
              a2.prototype.processData.call(
                this,
                b3
              );
              c2.stacking || (this.dataMin = m2 + h2, this.dataMax = t);
            };
            b2.prototype.toYData = function(a3) {
              return a3.isSum ? "sum" : a3.isIntermediateSum ? "intermediateSum" : a3.y;
            };
            b2.prototype.updateParallelArrays = function(b3, c2) {
              a2.prototype.updateParallelArrays.call(this, b3, c2);
              if ("sum" === this.yData[0] || "intermediateSum" === this.yData[0])
                this.yData[0] = null;
            };
            b2.prototype.pointAttribs = function(a3, b3) {
              var c2 = this.options.upColor;
              c2 && !a3.options.color && (a3.color = 0 < a3.y ? c2 : void 0);
              a3 = q.prototype.pointAttribs.call(this, a3, b3);
              delete a3.dashstyle;
              return a3;
            };
            b2.prototype.getGraphPath = function() {
              return [["M", 0, 0]];
            };
            b2.prototype.getCrispPath = function() {
              var a3 = this.data, b3 = this.yAxis, c2 = a3.length, e2 = Math.round(this.graph.strokeWidth()) % 2 / 2, d3 = Math.round(this.borderWidth) % 2 / 2, f2 = this.xAxis.reversed, g2 = this.yAxis.reversed, h2 = this.options.stacking, k2 = [], l2;
              for (l2 = 1; l2 < c2; l2++) {
                var m2 = a3[l2].shapeArgs;
                var n = a3[l2 - 1];
                var q2 = a3[l2 - 1].shapeArgs;
                var p2 = b3.waterfall.stacks[this.stackKey];
                var r2 = 0 < n.y ? -q2.height : 0;
                p2 && q2 && m2 && (p2 = p2[l2 - 1], h2 ? (p2 = p2.connectorThreshold, r2 = Math.round(b3.translate(
                  p2,
                  false,
                  true,
                  false,
                  true
                ) + (g2 ? r2 : 0)) - e2) : r2 = q2.y + n.minPointLengthOffset + d3 - e2, k2.push(["M", (q2.x || 0) + (f2 ? 0 : q2.width || 0), r2], ["L", (m2.x || 0) + (f2 ? m2.width || 0 : 0), r2]));
                q2 && k2.length && (!h2 && 0 > n.y && !g2 || 0 < n.y && g2) && ((n = k2[k2.length - 2]) && "number" === typeof n[2] && (n[2] += q2.height || 0), (n = k2[k2.length - 1]) && "number" === typeof n[2] && (n[2] += q2.height || 0));
              }
              return k2;
            };
            b2.prototype.drawGraph = function() {
              F.prototype.drawGraph.call(this);
              this.graph && this.graph.attr({ d: this.getCrispPath() });
            };
            b2.prototype.setStackedPoints = function() {
              function a3(a4, b4, c3, e3) {
                if (u) {
                  if (R)
                    for (c3; c3 < R; c3++)
                      u.stackState[c3] += e3;
                  else
                    u.stackState[0] = a4, R = u.stackState.length;
                  u.stackState.push(u.stackState[R - 1] + b4);
                }
              }
              var b3 = this.options, c2 = this.yAxis.waterfall.stacks, e2 = b3.threshold || 0, d3 = e2, f2 = d3, g2 = this.stackKey, h2 = this.xData, k2 = h2.length, l2, m2, n;
              this.yAxis.stacking.usePercentage = false;
              var q2 = l2 = m2 = d3;
              if (this.visible || !this.chart.options.chart.ignoreHiddenSeries) {
                var p2 = c2.changed;
                (n = c2.alreadyChanged) && 0 > n.indexOf(g2) && (p2 = true);
                c2[g2] || (c2[g2] = {});
                if (n = c2[g2])
                  for (var r2 = 0; r2 < k2; r2++) {
                    var w2 = h2[r2];
                    if (!n[w2] || p2)
                      n[w2] = {
                        negTotal: 0,
                        posTotal: 0,
                        stackTotal: 0,
                        threshold: 0,
                        stateIndex: 0,
                        stackState: [],
                        label: p2 && n[w2] ? n[w2].label : void 0
                      };
                    var u = n[w2];
                    var C = this.yData[r2];
                    0 <= C ? u.posTotal += C : u.negTotal += C;
                    var z = b3.data[r2];
                    w2 = u.absolutePos = u.posTotal;
                    var O = u.absoluteNeg = u.negTotal;
                    u.stackTotal = w2 + O;
                    var R = u.stackState.length;
                    z && z.isIntermediateSum ? (a3(m2, l2, 0, m2), m2 = l2, l2 = e2, d3 ^= f2, f2 ^= d3, d3 ^= f2) : z && z.isSum ? (a3(e2, q2, R, 0), d3 = e2) : (a3(d3, C, 0, q2), z && (q2 += C, l2 += C));
                    u.stateIndex++;
                    u.threshold = d3;
                    d3 += u.stackTotal;
                  }
                c2.changed = false;
                c2.alreadyChanged || (c2.alreadyChanged = []);
                c2.alreadyChanged.push(g2);
              }
            };
            b2.prototype.getExtremes = function() {
              var a3 = this.options.stacking;
              if (a3) {
                var b3 = this.yAxis;
                b3 = b3.waterfall.stacks;
                var c2 = this.stackedYNeg = [];
                var e2 = this.stackedYPos = [];
                "overlap" === a3 ? m(b3[this.stackKey], function(a4) {
                  c2.push(l(a4.stackState));
                  e2.push(p(a4.stackState));
                }) : m(b3[this.stackKey], function(a4) {
                  c2.push(a4.negTotal + a4.threshold);
                  e2.push(a4.posTotal + a4.threshold);
                });
                return { dataMin: l(c2), dataMax: p(e2) };
              }
              return { dataMin: this.dataMin, dataMax: this.dataMax };
            };
            b2.defaultOptions = k(q.defaultOptions, {
              dataLabels: { inside: true },
              lineWidth: 1,
              lineColor: "#333333",
              dashStyle: "Dot",
              borderColor: "#333333",
              states: { hover: { lineWidthPlus: 0 } }
            });
            return b2;
          }(q);
          r(a.prototype, { getZonesGraphs: F.prototype.getZonesGraphs, pointValKey: "y", showLine: true, pointClass: w });
          d2.registerSeriesType("waterfall", a);
          f.compose(b, c);
          "";
          return a;
        }
      );
      D(d, "Core/Axis/RadialAxis.js", [d["Core/Axis/AxisDefaults.js"], d["Core/Defaults.js"], d["Core/Globals.js"], d["Core/Utilities.js"]], function(b, c, d2, a) {
        var f = c.defaultOptions, h = d2.noop, n = a.addEvent, r = a.correctFloat, q = a.defined, F = a.extend, p = a.fireEvent, l = a.merge, e = a.pick, g = a.relativeLength, k = a.wrap, m;
        (function(a2) {
          function c2() {
            this.autoConnect = this.isCircular && "undefined" === typeof e(this.userMax, this.options.max) && r(this.endAngleRad - this.startAngleRad) === r(2 * Math.PI);
            !this.isCircular && this.chart.inverted && this.max++;
            this.autoConnect && (this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0);
          }
          function d3() {
            var a3 = this;
            return function() {
              if (a3.isRadial && a3.tickPositions && a3.options.labels && true !== a3.options.labels.allowOverlap)
                return a3.tickPositions.map(function(b2) {
                  return a3.ticks[b2] && a3.ticks[b2].label;
                }).filter(function(a4) {
                  return !!a4;
                });
            };
          }
          function m2() {
            return h;
          }
          function v(a3, b2, c3) {
            var e2 = this.pane.center, d4 = a3.value;
            if (this.isCircular) {
              if (q(d4))
                a3.point && (f2 = a3.point.shapeArgs || {}, f2.start && (d4 = this.chart.inverted ? this.translate(a3.point.rectPlotY, true) : a3.point.x));
              else {
                var f2 = a3.chartX || 0;
                var g2 = a3.chartY || 0;
                d4 = this.translate(Math.atan2(g2 - c3, f2 - b2) - this.startAngleRad, true);
              }
              a3 = this.getPosition(d4);
              f2 = a3.x;
              g2 = a3.y;
            } else
              q(d4) || (f2 = a3.chartX, g2 = a3.chartY), q(f2) && q(g2) && (c3 = e2[1] + this.chart.plotTop, d4 = this.translate(Math.min(Math.sqrt(Math.pow(f2 - b2, 2) + Math.pow(g2 - c3, 2)), e2[2] / 2) - e2[3] / 2, true));
            return [d4, f2 || 0, g2 || 0];
          }
          function w(a3, b2, c3) {
            a3 = this.pane.center;
            var d4 = this.chart, f2 = this.left || 0, g2 = this.top || 0, h2 = e(b2, a3[2] / 2 - this.offset);
            "undefined" === typeof c3 && (c3 = this.horiz ? 0 : this.center && -this.center[3] / 2);
            c3 && (h2 += c3);
            this.isCircular || "undefined" !== typeof b2 ? (b2 = this.chart.renderer.symbols.arc(f2 + a3[0], g2 + a3[1], h2, h2, { start: this.startAngleRad, end: this.endAngleRad, open: true, innerR: 0 }), b2.xBounds = [f2 + a3[0]], b2.yBounds = [g2 + a3[1] - h2]) : (b2 = this.postTranslate(this.angleRad, h2), b2 = [["M", this.center[0] + d4.plotLeft, this.center[1] + d4.plotTop], ["L", b2.x, b2.y]]);
            return b2;
          }
          function D2() {
            this.constructor.prototype.getOffset.call(this);
            this.chart.axisOffset[this.side] = 0;
          }
          function K(a3, b2, c3) {
            var d4 = this.chart, f2 = function(a4) {
              if ("string" === typeof a4) {
                var b3 = parseInt(a4, 10);
                u2.test(a4) && (b3 = b3 * C2 / 100);
                return b3;
              }
              return a4;
            }, g2 = this.center, h2 = this.startAngleRad, C2 = g2[2] / 2, k2 = Math.min(this.offset, 0), l2 = this.left || 0, m3 = this.top || 0, u2 = /%$/, z2 = this.isCircular, n2 = e(f2(c3.outerRadius), C2), P = f2(c3.innerRadius);
            f2 = e(f2(c3.thickness), 10);
            if ("polygon" === this.options.gridLineInterpolation)
              k2 = this.getPlotLinePath({ value: a3 }).concat(this.getPlotLinePath({ value: b2, reverse: true }));
            else {
              a3 = Math.max(a3, this.min);
              b2 = Math.min(b2, this.max);
              a3 = this.translate(a3);
              b2 = this.translate(b2);
              z2 || (n2 = a3 || 0, P = b2 || 0);
              if ("circle" !== c3.shape && z2)
                c3 = h2 + (a3 || 0), h2 += b2 || 0;
              else {
                c3 = -Math.PI / 2;
                h2 = 1.5 * Math.PI;
                var q2 = true;
              }
              n2 -= k2;
              k2 = d4.renderer.symbols.arc(l2 + g2[0], m3 + g2[1], n2, n2, { start: Math.min(c3, h2), end: Math.max(c3, h2), innerR: e(P, n2 - (f2 - k2)), open: q2 });
              z2 && (z2 = (h2 + c3) / 2, l2 = l2 + g2[0] + g2[2] / 2 * Math.cos(z2), k2.xBounds = z2 > -Math.PI / 2 && z2 < Math.PI / 2 ? [l2, d4.plotWidth] : [0, l2], k2.yBounds = [m3 + g2[1] + g2[2] / 2 * Math.sin(z2)], k2.yBounds[0] += z2 > -Math.PI && 0 > z2 || z2 > Math.PI ? -10 : 10);
            }
            return k2;
          }
          function x(a3) {
            var b2 = this, c3 = this.pane.center, e2 = this.chart, d4 = e2.inverted, f2 = a3.reverse, h2 = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {}, C2 = h2.innerRadius || "0%", k2 = h2.outerRadius || "100%", l2 = c3[0] + e2.plotLeft, m3 = c3[1] + e2.plotTop, u2 = this.height, z2 = a3.isCrosshair;
            h2 = c3[3] / 2;
            var n2 = a3.value, P;
            var q2 = this.getPosition(n2);
            var p2 = q2.x;
            q2 = q2.y;
            z2 && (q2 = this.getCrosshairPosition(a3, l2, m3), n2 = q2[0], p2 = q2[1], q2 = q2[2]);
            if (this.isCircular)
              n2 = Math.sqrt(Math.pow(p2 - l2, 2) + Math.pow(q2 - m3, 2)), f2 = "string" === typeof C2 ? g(C2, 1) : C2 / n2, e2 = "string" === typeof k2 ? g(k2, 1) : k2 / n2, c3 && h2 && (h2 /= n2, f2 < h2 && (f2 = h2), e2 < h2 && (e2 = h2)), c3 = [["M", l2 + f2 * (p2 - l2), m3 - f2 * (m3 - q2)], ["L", p2 - (1 - e2) * (p2 - l2), q2 + (1 - e2) * (m3 - q2)]];
            else if ((n2 = this.translate(n2)) && (0 > n2 || n2 > u2) && (n2 = 0), "circle" === this.options.gridLineInterpolation)
              c3 = this.getLinePath(0, n2, h2);
            else if (c3 = [], e2[d4 ? "yAxis" : "xAxis"].forEach(function(a4) {
              a4.pane === b2.pane && (P = a4);
            }), P)
              for (l2 = P.tickPositions, P.autoConnect && (l2 = l2.concat([l2[0]])), f2 && (l2 = l2.slice().reverse()), n2 && (n2 += h2), m3 = 0; m3 < l2.length; m3++)
                h2 = P.getPosition(l2[m3], n2), c3.push(m3 ? ["L", h2.x, h2.y] : ["M", h2.x, h2.y]);
            return c3;
          }
          function B(a3, b2) {
            a3 = this.translate(a3);
            return this.postTranslate(this.isCircular ? a3 : this.angleRad, e(this.isCircular ? b2 : 0 > a3 ? 0 : a3, this.center[2] / 2) - this.offset);
          }
          function y() {
            var a3 = this.center, b2 = this.chart, c3 = this.options.title;
            return { x: b2.plotLeft + a3[0] + (c3.x || 0), y: b2.plotTop + a3[1] - { high: 0.5, middle: 0.25, low: 0 }[c3.align] * a3[2] + (c3.y || 0) };
          }
          function H(a3) {
            a3.beforeSetTickPositions = c2;
            a3.createLabelCollector = d3;
            a3.getCrosshairPosition = v;
            a3.getLinePath = w;
            a3.getOffset = D2;
            a3.getPlotBandPath = K;
            a3.getPlotLinePath = x;
            a3.getPosition = B;
            a3.getTitlePosition = y;
            a3.postTranslate = u;
            a3.setAxisSize = z;
            a3.setAxisTranslation = O;
            a3.setOptions = R;
          }
          function t() {
            var a3 = this.chart, b2 = this.options, c3 = this.pane, d4 = c3 && c3.options;
            a3.angular && this.isXAxis || !c3 || !a3.angular && !a3.polar || (a3 = 2 * Math.PI, c3 = (e(d4.startAngle, 0) - 90) * Math.PI / 180, d4 = (e(d4.endAngle, e(d4.startAngle, 0) + 360) - 90) * Math.PI / 180, this.angleRad = (b2.angle || 0) * Math.PI / 180, this.startAngleRad = c3, this.endAngleRad = d4, this.offset = b2.offset || 0, b2 = (c3 % a3 + a3) % a3, d4 = (d4 % a3 + a3) % a3, b2 > Math.PI && (b2 -= a3), d4 > Math.PI && (d4 -= a3), this.normalizedStartAngleRad = b2, this.normalizedEndAngleRad = d4);
          }
          function J(a3) {
            this.isRadial && (a3.align = void 0, a3.preventDefault());
          }
          function N() {
            if (this.chart && this.chart.labelCollectors) {
              var a3 = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
              0 <= a3 && this.chart.labelCollectors.splice(a3, 1);
            }
          }
          function U(a3) {
            var c3 = this.chart, e2 = c3.inverted, d4 = c3.angular, f2 = c3.polar, g2 = this.isXAxis, k2 = this.coll, n2 = d4 && g2;
            a3 = a3.userOptions.pane || 0;
            a3 = this.pane = c3.pane && c3.pane[a3];
            var u2;
            if ("colorAxis" === k2)
              this.isRadial = false;
            else {
              if (d4) {
                if (n2 ? (this.isHidden = true, this.createLabelCollector = m2, this.getOffset = h, this.render = this.redraw = C, this.setTitle = this.setCategories = this.setScale = h) : H(this), u2 = !g2)
                  this.defaultPolarOptions = Y;
              } else
                f2 && (H(this), this.defaultPolarOptions = (u2 = this.horiz) ? X : l("xAxis" === k2 ? b.defaultXAxisOptions : b.defaultYAxisOptions, Z), e2 && "yAxis" === k2 && (this.defaultPolarOptions.stackLabels = b.defaultYAxisOptions.stackLabels, this.defaultPolarOptions.reversedStacks = true));
              d4 || f2 ? (this.isRadial = true, this.labelCollector || (this.labelCollector = this.createLabelCollector()), this.labelCollector && c3.labelCollectors.push(this.labelCollector)) : this.isRadial = false;
              a3 && u2 && (a3.axis = this);
              this.isCircular = u2;
            }
          }
          function A() {
            this.isRadial && this.beforeSetTickPositions();
          }
          function M(a3) {
            var b2 = this.label;
            if (b2) {
              var c3 = this.axis, d4 = b2.getBBox(), f2 = c3.options.labels, h2 = (c3.translate(this.pos) + c3.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360, C2 = Math.round(h2), k2 = q(f2.y) ? 0 : 0.3 * -d4.height, l2 = f2.y, m3 = 20, u2 = f2.align, n2 = "end", z2 = 0 > C2 ? C2 + 360 : C2, p2 = z2, O2 = 0, t2 = 0;
              if (c3.isRadial) {
                var r2 = c3.getPosition(this.pos, c3.center[2] / 2 + g(e(f2.distance, -25), c3.center[2] / 2, -c3.center[2] / 2));
                "auto" === f2.rotation ? b2.attr({ rotation: h2 }) : q(l2) || (l2 = c3.chart.renderer.fontMetrics(b2.styles && b2.styles.fontSize).b - d4.height / 2);
                q(u2) || (c3.isCircular ? (d4.width > c3.len * c3.tickInterval / (c3.max - c3.min) && (m3 = 0), u2 = h2 > m3 && h2 < 180 - m3 ? "left" : h2 > 180 + m3 && h2 < 360 - m3 ? "right" : "center") : u2 = "center", b2.attr({ align: u2 }));
                if ("auto" === u2 && 2 === c3.tickPositions.length && c3.isCircular) {
                  90 < z2 && 180 > z2 ? z2 = 180 - z2 : 270 < z2 && 360 >= z2 && (z2 = 540 - z2);
                  180 < p2 && 360 >= p2 && (p2 = 360 - p2);
                  if (c3.pane.options.startAngle === C2 || c3.pane.options.startAngle === C2 + 360 || c3.pane.options.startAngle === C2 - 360)
                    n2 = "start";
                  u2 = -90 <= C2 && 90 >= C2 || -360 <= C2 && -270 >= C2 || 270 <= C2 && 360 >= C2 ? "start" === n2 ? "right" : "left" : "start" === n2 ? "left" : "right";
                  70 < p2 && 110 > p2 && (u2 = "center");
                  15 > z2 || 180 <= z2 && 195 > z2 ? O2 = 0.3 * d4.height : 15 <= z2 && 35 >= z2 ? O2 = "start" === n2 ? 0 : 0.75 * d4.height : 195 <= z2 && 215 >= z2 ? O2 = "start" === n2 ? 0.75 * d4.height : 0 : 35 < z2 && 90 >= z2 ? O2 = "start" === n2 ? 0.25 * -d4.height : d4.height : 215 < z2 && 270 >= z2 && (O2 = "start" === n2 ? d4.height : 0.25 * -d4.height);
                  15 > p2 ? t2 = "start" === n2 ? 0.15 * -d4.height : 0.15 * d4.height : 165 < p2 && 180 >= p2 && (t2 = "start" === n2 ? 0.15 * d4.height : 0.15 * -d4.height);
                  b2.attr({ align: u2 });
                  b2.translate(t2, O2 + k2);
                }
                a3.pos.x = r2.x + (f2.x || 0);
                a3.pos.y = r2.y + (l2 || 0);
              }
            }
          }
          function S(a3) {
            this.axis.getPosition && F(a3.pos, this.axis.getPosition(this.pos));
          }
          function u(a3, b2) {
            var c3 = this.chart, e2 = this.center;
            a3 = this.startAngleRad + a3;
            return { x: c3.plotLeft + e2[0] + Math.cos(a3) * b2, y: c3.plotTop + e2[1] + Math.sin(a3) * b2 };
          }
          function C() {
            this.isDirty = false;
          }
          function z() {
            this.constructor.prototype.setAxisSize.call(this);
            if (this.isRadial) {
              this.pane.updateCenter(this);
              var a3 = this.center = this.pane.center.slice();
              if (this.isCircular)
                this.sector = this.endAngleRad - this.startAngleRad;
              else {
                var b2 = this.postTranslate(this.angleRad, a3[3] / 2);
                a3[0] = b2.x - this.chart.plotLeft;
                a3[1] = b2.y - this.chart.plotTop;
              }
              this.len = this.width = this.height = (a3[2] - a3[3]) * e(this.sector, 1) / 2;
            }
          }
          function O() {
            this.constructor.prototype.setAxisTranslation.call(this);
            this.center && (this.transA = this.isCircular ? (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1) : (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1), this.minPixelPadding = this.isXAxis ? this.transA * this.minPointOffset : 0);
          }
          function R(a3) {
            a3 = this.options = l(this.constructor.defaultOptions, this.defaultPolarOptions, f[this.coll], a3);
            a3.plotBands || (a3.plotBands = []);
            p(this, "afterSetOptions");
          }
          function W(a3, b2, c3, e2, d4, f2, g2) {
            var h2 = this.axis;
            h2.isRadial ? (a3 = h2.getPosition(this.pos, h2.center[2] / 2 + e2), b2 = ["M", b2, c3, "L", a3.x, a3.y]) : b2 = a3.call(this, b2, c3, e2, d4, f2, g2);
            return b2;
          }
          var T = [], X = {
            gridLineWidth: 1,
            labels: { align: void 0, distance: 15, x: 0, y: void 0, style: { textOverflow: "none" } },
            maxPadding: 0,
            minPadding: 0,
            showLastLabel: false,
            tickLength: 0
          }, Y = { labels: { align: "center", x: 0, y: void 0 }, minorGridLineWidth: 0, minorTickInterval: "auto", minorTickLength: 10, minorTickPosition: "inside", minorTickWidth: 1, tickLength: 10, tickPosition: "inside", tickWidth: 2, title: { rotation: 0 }, zIndex: 2 }, Z = { gridLineInterpolation: "circle", gridLineWidth: 1, labels: { align: "right", x: -3, y: -2 }, showLastLabel: false, title: { x: 4, text: null, rotation: 90 } };
          a2.compose = function(a3, b2) {
            -1 === T.indexOf(a3) && (T.push(a3), n(a3, "afterInit", t), n(a3, "autoLabelAlign", J), n(a3, "destroy", N), n(a3, "init", U), n(a3, "initialAxisTranslation", A));
            -1 === T.indexOf(b2) && (T.push(b2), n(b2, "afterGetLabelPosition", M), n(b2, "afterGetPosition", S), k(b2.prototype, "getMarkPath", W));
            return a3;
          };
        })(m || (m = {}));
        return m;
      });
      D(d, "Series/PolarComposition.js", [d["Core/Animation/AnimationUtilities.js"], d["Core/Globals.js"], d["Extensions/Pane.js"], d["Core/Axis/RadialAxis.js"], d["Core/Utilities.js"]], function(b, c, d2, a, f) {
        function h(a2, b2, c2, e2) {
          var d3 = e2 ? 1 : 0;
          var f2 = 0 <= b2 && b2 <= a2.length - 1 ? b2 : 0 > b2 ? a2.length - 1 + b2 : 0;
          b2 = 0 > f2 - 1 ? a2.length - (1 + d3) : f2 - 1;
          var g2 = a2[b2];
          d3 = a2[f2 + 1 > a2.length - 1 ? d3 : f2 + 1];
          var C = g2.plotY;
          var k2 = d3.plotX;
          var l2 = d3.plotY;
          d3 = a2[f2].plotX;
          f2 = a2[f2].plotY;
          g2 = (1.5 * d3 + g2.plotX) / 2.5;
          C = (1.5 * f2 + C) / 2.5;
          k2 = (1.5 * d3 + k2) / 2.5;
          var m2 = (1.5 * f2 + l2) / 2.5;
          l2 = Math.sqrt(Math.pow(g2 - d3, 2) + Math.pow(C - f2, 2));
          var z = Math.sqrt(Math.pow(k2 - d3, 2) + Math.pow(m2 - f2, 2));
          g2 = Math.atan2(C - f2, g2 - d3);
          m2 = Math.PI / 2 + (g2 + Math.atan2(m2 - f2, k2 - d3)) / 2;
          Math.abs(g2 - m2) > Math.PI / 2 && (m2 -= Math.PI);
          g2 = d3 + Math.cos(m2) * l2;
          C = f2 + Math.sin(m2) * l2;
          k2 = d3 + Math.cos(Math.PI + m2) * z;
          m2 = f2 + Math.sin(Math.PI + m2) * z;
          d3 = {
            rightContX: k2,
            rightContY: m2,
            leftContX: g2,
            leftContY: C,
            plotX: d3,
            plotY: f2
          };
          c2 && (d3.prevPointCont = h(a2, b2, false, e2));
          return d3;
        }
        function n() {
          (this.pane || []).forEach(function(a2) {
            a2.render();
          });
        }
        function r(a2) {
          var b2 = a2.args[0].xAxis, c2 = a2.args[0].yAxis;
          a2 = a2.args[0].chart;
          b2 && c2 && ("polygon" === c2.gridLineInterpolation ? (b2.startOnTick = true, b2.endOnTick = true) : "polygon" === b2.gridLineInterpolation && a2.inverted && (c2.startOnTick = true, c2.endOnTick = true));
        }
        function q() {
          var a2 = this;
          this.pane || (this.pane = []);
          this.options.pane = V(this.options.pane);
          this.options.pane.forEach(function(b2) {
            new d2(
              b2,
              a2
            );
          }, this);
        }
        function D2(a2) {
          var b2 = a2.args.marker, c2 = this.chart.xAxis[0], d3 = this.chart.yAxis[0], e2 = this.chart.inverted, f2 = e2 ? d3 : c2;
          c2 = e2 ? c2 : d3;
          if (this.chart.polar) {
            a2.preventDefault();
            d3 = (b2.attr ? b2.attr("start") : b2.start) - f2.startAngleRad;
            e2 = b2.attr ? b2.attr("r") : b2.r;
            var g2 = (b2.attr ? b2.attr("end") : b2.end) - f2.startAngleRad;
            b2 = b2.attr ? b2.attr("innerR") : b2.innerR;
            a2.result.x = d3 + f2.pos;
            a2.result.width = g2 - d3;
            a2.result.y = c2.len + c2.pos - b2;
            a2.result.height = b2 - e2;
          }
        }
        function p(a2) {
          var b2 = this.chart;
          if (b2.polar && b2.hoverPane && b2.hoverPane.axis) {
            a2.preventDefault();
            var c2 = b2.hoverPane.center, d3 = this.mouseDownX || 0, e2 = this.mouseDownY || 0, f2 = a2.args.chartY, g2 = a2.args.chartX, h2 = 2 * Math.PI, l2 = b2.hoverPane.axis.startAngleRad, m2 = b2.hoverPane.axis.endAngleRad, n2 = b2.inverted ? b2.xAxis[0] : b2.yAxis[0], u = {}, q2 = "arc";
            u.x = c2[0] + b2.plotLeft;
            u.y = c2[1] + b2.plotTop;
            if (this.zoomHor) {
              var p2 = 0 < l2 ? m2 - l2 : Math.abs(l2) + Math.abs(m2), t2 = Math.atan2(e2 - b2.plotTop - c2[1], d3 - b2.plotLeft - c2[0]) - l2, r2 = Math.atan2(f2 - b2.plotTop - c2[1], g2 - b2.plotLeft - c2[0]) - l2;
              u.r = c2[2] / 2;
              u.innerR = c2[3] / 2;
              0 >= t2 && (t2 += h2);
              0 >= r2 && (r2 += h2);
              r2 < t2 && (r2 = [t2, t2 = r2][0]);
              p2 < h2 && l2 + r2 > m2 + (h2 - p2) / 2 && (r2 = t2, t2 = 0 >= l2 ? l2 : 0);
              h2 = u.start = Math.max(t2 + l2, l2);
              t2 = u.end = Math.min(r2 + l2, m2);
              "polygon" === n2.options.gridLineInterpolation && (r2 = b2.hoverPane.axis, p2 = h2 - r2.startAngleRad + r2.pos, t2 -= h2, q2 = n2.getPlotLinePath({ value: n2.max }), h2 = r2.toValue(p2), p2 = r2.toValue(p2 + t2), h2 < r2.getExtremes().min && (t2 = r2.getExtremes(), h2 = t2.max - (t2.min - h2)), p2 < r2.getExtremes().min && (t2 = r2.getExtremes(), p2 = t2.max - (t2.min - p2)), p2 < h2 && (p2 = [h2, h2 = p2][0]), q2 = k(q2, h2, p2, r2), q2.push(["L", c2[0] + b2.plotLeft, b2.plotTop + c2[1]]), u.d = q2, q2 = "path");
            }
            this.zoomVert && (r2 = b2.inverted ? b2.xAxis[0] : b2.yAxis[0], d3 = Math.sqrt(Math.pow(d3 - b2.plotLeft - c2[0], 2) + Math.pow(e2 - b2.plotTop - c2[1], 2)), f2 = Math.sqrt(Math.pow(g2 - b2.plotLeft - c2[0], 2) + Math.pow(f2 - b2.plotTop - c2[1], 2)), f2 < d3 && (d3 = [f2, f2 = d3][0]), f2 > c2[2] / 2 && (f2 = c2[2] / 2), d3 < c2[3] / 2 && (d3 = c2[3] / 2), this.zoomHor || (u.start = l2, u.end = m2), u.r = f2, u.innerR = d3, "polygon" === r2.options.gridLineInterpolation && (t2 = r2.toValue(r2.len + r2.pos - d3), h2 = r2.toValue(r2.len + r2.pos - f2), q2 = r2.getPlotLinePath({ value: h2 }).concat(r2.getPlotLinePath({ value: t2, reverse: true })), u.d = q2, q2 = "path"));
            this.zoomHor && this.zoomVert && "polygon" === n2.options.gridLineInterpolation && (r2 = b2.hoverPane.axis, h2 = u.start || 0, t2 = u.end || 0, p2 = h2 - r2.startAngleRad + r2.pos, t2 -= h2, h2 = r2.toValue(p2), p2 = r2.toValue(p2 + t2), u.d instanceof Array && (c2 = u.d.slice(0, u.d.length / 2), l2 = u.d.slice(u.d.length / 2, u.d.length), l2 = K([], l2, true).reverse(), b2 = b2.hoverPane.axis, c2 = k(c2, h2, p2, b2), (l2 = k(l2, h2, p2, b2)) && (l2[0][0] = "L"), l2 = K([], l2, true).reverse(), u.d = c2.concat(l2), q2 = "path"));
            a2.attrs = u;
            a2.shapeType = q2;
          }
        }
        function l() {
          var a2 = this.chart;
          a2.polar && (this.polar = new S(this), a2.inverted && (this.isRadialSeries = true, this.is("column") && (this.isRadialBar = true)));
        }
        function e() {
          if (this.chart.polar && this.xAxis) {
            var a2 = this.chart;
            (this.kdByAngle = a2.tooltip && a2.tooltip.shared) ? this.searchPoint = g : this.options.findNearestPointBy = "xy";
            for (var b2 = this.points, d3 = b2.length; d3--; )
              this.preventPostTranslate || this.polar.toXY(b2[d3]), a2.hasParallelCoordinates || this.yAxis.reversed || (J(b2[d3].y, Number.MIN_VALUE) < this.yAxis.min || b2[d3].x < this.xAxis.min || b2[d3].x > this.xAxis.max ? (b2[d3].isNull = true, b2[d3].plotY = NaN) : b2[d3].isNull = b2[d3].isValid && !b2[d3].isValid());
            this.hasClipCircleSetter || (this.hasClipCircleSetter = !!this.eventsToUnbind.push(B(
              this,
              "afterRender",
              function() {
                if (a2.polar) {
                  var b3 = this.yAxis.pane.center;
                  if (this.clipCircle)
                    this.clipCircle.animate({ x: b3[0], y: b3[1], r: b3[2] / 2, innerR: b3[3] / 2 });
                  else {
                    var d4 = a2.renderer, e2 = b3[0], f2 = b3[1], g2 = b3[2] / 2, h2 = b3[3] / 2;
                    b3 = U();
                    var k2 = d4.createElement("clipPath").attr({ id: b3 }).add(d4.defs);
                    d4 = h2 ? d4.arc(e2, f2, g2, h2, 0, 2 * Math.PI).add(k2) : d4.circle(e2, f2, g2).add(k2);
                    d4.id = b3;
                    d4.clipPath = k2;
                    this.clipCircle = d4;
                  }
                  this.group.clip(this.clipCircle);
                  this.setClip = c.noop;
                }
              }
            )));
          }
        }
        function g(a2) {
          var b2 = this.chart, c2 = this.xAxis;
          c2 = c2.pane && c2.pane.center;
          return this.searchKDTree({ clientX: 180 + -180 / Math.PI * Math.atan2(a2.chartX - (c2 && c2[0] || 0) - b2.plotLeft, a2.chartY - (c2 && c2[1] || 0) - b2.plotTop) });
        }
        function k(a2, b2, c2, d3) {
          var e2 = d3.tickInterval;
          d3 = d3.tickPositions;
          var f2 = H(d3, function(a3) {
            return a3 >= c2;
          }), g2 = H(K([], d3, true).reverse(), function(a3) {
            return a3 <= b2;
          });
          y(f2) || (f2 = d3[d3.length - 1]);
          y(g2) || (g2 = d3[0], f2 += e2, a2[0][0] = "L", a2.unshift(a2[a2.length - 3]));
          a2 = a2.slice(d3.indexOf(g2), d3.indexOf(f2) + 1);
          a2[0][0] = "M";
          return a2;
        }
        function m(a2, b2) {
          return H(this.pane || [], function(a3) {
            return a3.options.id === b2;
          }) || a2.call(this, b2);
        }
        function N(a2, b2, c2, d3, e2, f2) {
          var g2 = this.chart, h2 = J(d3.inside, !!this.options.stacking);
          g2.polar ? (a2 = b2.rectPlotX / Math.PI * 180, g2.inverted ? (this.forceDL = g2.isInsidePlot(b2.plotX, b2.plotY), h2 && b2.shapeArgs ? (e2 = b2.shapeArgs, e2 = this.yAxis.postTranslate(((e2.start || 0) + (e2.end || 0)) / 2 - this.xAxis.startAngleRad, b2.barX + b2.pointWidth / 2), e2 = { x: e2.x - g2.plotLeft, y: e2.y - g2.plotTop }) : b2.tooltipPos && (e2 = { x: b2.tooltipPos[0], y: b2.tooltipPos[1] }), d3.align = J(d3.align, "center"), d3.verticalAlign = J(d3.verticalAlign, "middle")) : (null === d3.align && (d3.align = 20 < a2 && 160 > a2 ? "left" : 200 < a2 && 340 > a2 ? "right" : "center"), null === d3.verticalAlign && (d3.verticalAlign = 45 > a2 || 315 < a2 ? "bottom" : 135 < a2 && 225 > a2 ? "top" : "middle")), Object.getPrototypeOf(Object.getPrototypeOf(this)).alignDataLabel.call(this, b2, c2, d3, e2, f2), this.isRadialBar && b2.shapeArgs && b2.shapeArgs.start === b2.shapeArgs.end ? c2.hide() : c2.show()) : a2.call(this, b2, c2, d3, e2, f2);
        }
        function G(a2) {
          var b2 = this.options, c2 = b2.stacking, d3 = this.chart, e2 = this.xAxis, g2 = this.yAxis, h2 = g2.reversed, k2 = g2.center, l2 = e2.startAngleRad, m2 = e2.endAngleRad - l2, n2 = 0, p2 = 0, q2 = 0;
          this.preventPostTranslate = true;
          a2.call(this);
          if (e2.isRadial) {
            a2 = this.points;
            e2 = a2.length;
            var r2 = g2.translate(g2.min);
            var u = g2.translate(g2.max);
            b2 = b2.threshold || 0;
            d3.inverted && t(b2) && (n2 = g2.translate(b2), y(n2) && (0 > n2 ? n2 = 0 : n2 > m2 && (n2 = m2), this.translatedThreshold = n2 + l2));
            for (; e2--; ) {
              b2 = a2[e2];
              var v2 = b2.barX;
              var w = b2.x;
              var x2 = b2.y;
              b2.shapeType = "arc";
              if (d3.inverted) {
                b2.plotY = g2.translate(x2);
                c2 && g2.stacking ? (x2 = g2.stacking.stacks[(0 > x2 ? "-" : "") + this.stackKey], this.visible && x2 && x2[w] && !b2.isNull && (q2 = x2[w].points[this.getStackIndicator(void 0, w, this.index).key], p2 = g2.translate(q2[0]), q2 = g2.translate(q2[1]), y(p2) && (p2 = f.clamp(
                  p2,
                  0,
                  m2
                )))) : (p2 = n2, q2 = b2.plotY);
                p2 > q2 && (q2 = [p2, p2 = q2][0]);
                if (!h2)
                  if (p2 < r2)
                    p2 = r2;
                  else if (q2 > u)
                    q2 = u;
                  else {
                    if (q2 < r2 || p2 > u)
                      p2 = q2 = 0;
                  }
                else if (q2 > r2)
                  q2 = r2;
                else if (p2 < u)
                  p2 = u;
                else if (p2 > r2 || q2 < u)
                  p2 = q2 = m2;
                g2.min > g2.max && (p2 = q2 = h2 ? m2 : 0);
                p2 += l2;
                q2 += l2;
                k2 && (b2.barX = v2 += k2[3] / 2);
                w = Math.max(v2, 0);
                x2 = Math.max(v2 + b2.pointWidth, 0);
                b2.shapeArgs = { x: k2 && k2[0], y: k2 && k2[1], r: x2, innerR: w, start: p2, end: q2 };
                b2.opacity = p2 === q2 ? 0 : void 0;
                b2.plotY = (y(this.translatedThreshold) && (p2 < this.translatedThreshold ? p2 : q2)) - l2;
              } else
                p2 = v2 + l2, b2.shapeArgs = this.polar.arc(b2.yBottom, b2.plotY, p2, p2 + b2.pointWidth);
              this.polar.toXY(b2);
              d3.inverted ? (v2 = g2.postTranslate(b2.rectPlotY, v2 + b2.pointWidth / 2), b2.tooltipPos = [v2.x - d3.plotLeft, v2.y - d3.plotTop]) : b2.tooltipPos = [b2.plotX, b2.plotY];
              k2 && (b2.ttBelow = b2.plotY > k2[1]);
            }
          }
        }
        function L(a2, b2) {
          var c2 = this;
          if (this.chart.polar) {
            b2 = b2 || this.points;
            for (var d3 = 0; d3 < b2.length; d3++)
              if (!b2[d3].isNull) {
                var e2 = d3;
                break;
              }
            if (false !== this.options.connectEnds && "undefined" !== typeof e2) {
              this.connectEnds = true;
              b2.splice(b2.length, 0, b2[e2]);
              var f2 = true;
            }
            b2.forEach(function(a3) {
              "undefined" === typeof a3.polarPlotY && c2.polar.toXY(a3);
            });
          }
          e2 = a2.apply(this, [].slice.call(
            arguments,
            1
          ));
          f2 && b2.pop();
          return e2;
        }
        function E(a2, b2) {
          var c2 = this.chart, d3 = { xAxis: [], yAxis: [] };
          c2.polar ? c2.axes.forEach(function(a3) {
            if ("colorAxis" !== a3.coll) {
              var e2 = a3.isXAxis, f2 = a3.center, g2 = b2.chartX - f2[0] - c2.plotLeft;
              f2 = b2.chartY - f2[1] - c2.plotTop;
              d3[e2 ? "xAxis" : "yAxis"].push({ axis: a3, value: a3.translate(e2 ? Math.PI - Math.atan2(g2, f2) : Math.sqrt(Math.pow(g2, 2) + Math.pow(f2, 2)), true) });
            }
          }) : d3 = a2.call(this, b2);
          return d3;
        }
        function v(a2, b2) {
          this.chart.polar || a2.call(this, b2);
        }
        function Q(a2, b2) {
          var d3 = this, e2 = this.chart, f2 = this.group, g2 = this.markerGroup, h2 = this.xAxis && this.xAxis.center, k2 = e2.plotLeft, l2 = e2.plotTop, m2 = this.options.animation, n2, p2, q2, r2;
          if (e2.polar)
            if (d3.isRadialBar)
              b2 || (d3.startAngleRad = J(d3.translatedThreshold, d3.xAxis.startAngleRad), c.seriesTypes.pie.prototype.animate.call(d3, b2));
            else {
              if (e2.renderer.isSVG)
                if (m2 = x(m2), d3.is("column")) {
                  if (!b2) {
                    var t2 = h2[3] / 2;
                    d3.points.forEach(function(a3) {
                      n2 = a3.graphic;
                      q2 = (p2 = a3.shapeArgs) && p2.r;
                      r2 = p2 && p2.innerR;
                      n2 && p2 && (n2.attr({ r: t2, innerR: t2 }), n2.animate({ r: q2, innerR: r2 }, d3.options.animation));
                    });
                  }
                } else
                  b2 ? (a2 = {
                    translateX: h2[0] + k2,
                    translateY: h2[1] + l2,
                    scaleX: 1e-3,
                    scaleY: 1e-3
                  }, f2.attr(a2), g2 && g2.attr(a2)) : (a2 = { translateX: k2, translateY: l2, scaleX: 1, scaleY: 1 }, f2.animate(a2, m2), g2 && g2.animate(a2, m2));
            }
          else
            a2.call(this, b2);
        }
        function I(a2, b2, c2, d3) {
          this.chart.polar ? d3 ? (a2 = h(b2, d3, true, this.connectEnds), b2 = a2.prevPointCont && a2.prevPointCont.rightContX, c2 = a2.prevPointCont && a2.prevPointCont.rightContY, a2 = ["C", t(b2) ? b2 : a2.plotX, t(c2) ? c2 : a2.plotY, t(a2.leftContX) ? a2.leftContX : a2.plotX, t(a2.leftContY) ? a2.leftContY : a2.plotY, a2.plotX, a2.plotY]) : a2 = ["M", c2.plotX, c2.plotY] : a2 = a2.call(this, b2, c2, d3);
          return a2;
        }
        var K = this && this.__spreadArray || function(a2, b2, c2) {
          if (c2 || 2 === arguments.length)
            for (var d3 = 0, e2 = b2.length, f2; d3 < e2; d3++)
              !f2 && d3 in b2 || (f2 || (f2 = Array.prototype.slice.call(b2, 0, d3)), f2[d3] = b2[d3]);
          return a2.concat(f2 || Array.prototype.slice.call(b2));
        }, x = b.animObject, B = f.addEvent, y = f.defined, H = f.find, t = f.isNumber, J = f.pick, V = f.splat, U = f.uniqueKey, A = f.wrap, M = [], S = function() {
          function b2(a2) {
            this.series = a2;
          }
          b2.compose = function(b3, c2, d3, f2, g2, h2, k2, t2, u) {
            a.compose(b3, g2);
            -1 === M.indexOf(c2) && (M.push(c2), B(c2, "afterDrawChartBox", n), B(c2, "getAxes", q), B(c2, "init", r), A(
              c2.prototype,
              "get",
              m
            ));
            -1 === M.indexOf(d3) && (M.push(d3), b3 = d3.prototype, A(b3, "getCoordinates", E), A(b3, "pinch", v), B(d3, "getSelectionMarkerAttrs", p), B(d3, "getSelectionBox", D2));
            -1 === M.indexOf(f2) && (M.push(f2), B(f2, "afterInit", l), B(f2, "afterTranslate", e, { order: 2 }), A(f2.prototype, "animate", Q));
            k2 && -1 === M.indexOf(k2) && (M.push(k2), d3 = k2.prototype, A(d3, "alignDataLabel", N), A(d3, "animate", Q), A(d3, "translate", G));
            t2 && -1 === M.indexOf(t2) && (M.push(t2), A(t2.prototype, "getGraphPath", L));
            u && -1 === M.indexOf(u) && (M.push(u), t2 = u.prototype, A(t2, "getPointSpline", I), h2 && -1 === M.indexOf(h2) && (M.push(h2), h2.prototype.getPointSpline = t2.getPointSpline));
          };
          b2.prototype.arc = function(a2, b3, c2, d3) {
            var e2 = this.series, f2 = e2.xAxis.center, g2 = e2.yAxis.len, h2 = f2[3] / 2;
            b3 = g2 - b3 + h2;
            a2 = g2 - J(a2, g2) + h2;
            e2.yAxis.reversed && (0 > b3 && (b3 = h2), 0 > a2 && (a2 = h2));
            return { x: f2[0], y: f2[1], r: b3, innerR: a2, start: c2, end: d3 };
          };
          b2.prototype.toXY = function(a2) {
            var b3 = this.series, c2 = b3.chart, d3 = b3.xAxis, e2 = b3.yAxis, f2 = a2.plotX, g2 = c2.inverted, h2 = a2.y, k2 = a2.plotY, l2 = g2 ? f2 : e2.len - k2;
            g2 && b3 && !b3.isRadialBar && (a2.plotY = k2 = t(h2) ? e2.translate(h2) : 0);
            a2.rectPlotX = f2;
            a2.rectPlotY = k2;
            e2.center && (l2 += e2.center[3] / 2);
            t(k2) && (e2 = g2 ? e2.postTranslate(k2, l2) : d3.postTranslate(f2, l2), a2.plotX = a2.polarPlotX = e2.x - c2.plotLeft, a2.plotY = a2.polarPlotY = e2.y - c2.plotTop);
            b3.kdByAngle ? (b3 = (f2 / Math.PI * 180 + d3.pane.options.startAngle) % 360, 0 > b3 && (b3 += 360), a2.clientX = b3) : a2.clientX = a2.plotX;
          };
          return b2;
        }();
        return S;
      });
      D(d, "masters/highcharts-more.src.js", [d["Core/Globals.js"], d["Core/Series/SeriesRegistry.js"], d["Series/Bubble/BubbleSeries.js"], d["Series/PackedBubble/PackedBubbleSeries.js"], d["Series/PolarComposition.js"]], function(b, c, d2, a, f) {
        d2.compose(
          b.Axis,
          b.Chart,
          b.Legend,
          b.Series
        );
        a.compose(b.Axis, b.Chart, b.Legend, b.Series);
        f.compose(b.Axis, b.Chart, b.Pointer, b.Series, b.Tick, c.seriesTypes.areasplinerange, c.seriesTypes.column, c.seriesTypes.line, c.seriesTypes.spline);
      });
    });
  }
});

// dep:highcharts_highcharts-more
var highcharts_highcharts_more_default = require_highcharts_more();
export {
  highcharts_highcharts_more_default as default
};
//# sourceMappingURL=highcharts_highcharts-more.js.map
